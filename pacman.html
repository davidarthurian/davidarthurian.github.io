<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pac-Man | David Arthurian</title>
  <style>
    :root{
      --bg:#0b1220;
      --text:#e6edf7;
      --muted:#9fb0c6;
      --border:rgba(255,255,255,0.10);
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      min-height:100vh;
      display:flex;
      flex-direction:column;
      align-items:center;
      padding:20px 14px;
      gap:12px;
    }
    .wrap{
      width:min(980px, 100%);
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .topRow{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
      padding:12px 14px;
      border:1px solid var(--border);
      border-radius:14px;
      background:rgba(255,255,255,0.03);
    }
    .stats{
      display:flex;
      gap:14px;
      flex-wrap:wrap;
      color:var(--muted);
      font-size:0.95rem;
    }
    .stats b{ color:var(--text); }
    button{
      border:1px solid var(--border);
      background:rgba(255,255,255,0.03);
      color:var(--text);
      padding:8px 12px;
      border-radius:12px;
      font-weight:700;
      cursor:pointer;
    }
    button:hover{ background:rgba(255,255,255,0.06); }
    canvas{
      width:100%;
      height:auto;
      border:1px solid var(--border);
      border-radius:16px;
      background:#050a12;
      display:block;
    }
    .hint{
      color:var(--muted);
      font-size:0.95rem;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="topRow">
      <div class="stats">
        <div>Score: <b id="score">0</b></div>
        <div>Lives: <b id="lives">3</b></div>
        <div>Status: <b id="status">Ready</b></div>
      </div>
      <div style="display:flex; gap:10px; flex-wrap:wrap;">
        <button id="startBtn">Start</button>
        <button id="resetBtn">Reset</button>
      </div>
    </div>

    <canvas id="c"></canvas>
    <div class="hint">Controls: Arrow keys / WASD. Tunnel wrap works on the open row (0 tiles).</div>
  </div>

<script>
(() => {
  // Tile legend:
  // 0 = empty corridor (used for tunnel row)
  // 1 = wall
  // 2 = pellet
  // 3 = power pellet
  // 4 = ghost house floor (walkable)

  const MAP = [
    "1111111111111111111111111111",
    "1222222222222112222222222221",
    "1211112111112112111112111121",
    "1311112111112112111112111131",
    "1211112111112112111112111121",
    "1222222222222222222222222221",
    "1211112112111111112112111121",
    "1211112112111111112112111121",
    "1222222112222112222112222221",
    "1111112111112112111112111111",
    "0000012111112112111112100000",
    "1111112112112222112112111111",
    "2222222222114444112222222222",
    "1111112112111111112112111111",
    "0000012111112112111112100000",
    "1111112112111111112112111111",
    "1222222222222112222222222221",
    "1211112111112112111112111121",
    "1311122222222222222222111131",
    "1111122112111111112112111111",
    "1222222112111111112112222221",
    "1211111112222112222111111121",
    "1211111111112112111111111121",
    "1222222222222222222222222221",
    "1111111111111111111111111111",
  ];

  const grid = MAP.map(row => row.split("").map(n => Number(n)));
  const ROWS = grid.length;
  const COLS = grid[0].length;

  // --- Canvas sizing ---
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  const TILE = 22;
  canvas.width = COLS * TILE;
  canvas.height = ROWS * TILE;

  // --- UI ---
  const scoreEl = document.getElementById("score");
  const livesEl = document.getElementById("lives");
  const statusEl = document.getElementById("status");
  const startBtn = document.getElementById("startBtn");
  const resetBtn = document.getElementById("resetBtn");

  // --- Helpers ---
  const tileRow = (y) => Math.floor(y / TILE);
  const tileCol = (x) => Math.floor(x / TILE);
  const centerOf = (r, c) => ({ x: c * TILE + TILE/2, y: r * TILE + TILE/2 });

  function isTunnelRow(r){
    if (r < 0 || r >= ROWS) return false;
    return grid[r][0] === 0 && grid[r][COLS-1] === 0;
  }

  function wrapXIfTunnel(r, x){
    if (!isTunnelRow(r)) return x;
    const W = COLS * TILE;
    if (x < 0) return x + W;
    if (x >= W) return x - W;
    return x;
  }

  function tileAt(r, c){
    if (r < 0 || r >= ROWS) return 1;
    // Only wrap columns for tunnel rows
    if (c < 0 || c >= COLS) {
      if (!isTunnelRow(r)) return 1;
      c = (c + COLS) % COLS;
    }
    return grid[r][c];
  }

  function setTile(r, c, v){
    if (r < 0 || r >= ROWS) return;
    if (c < 0 || c >= COLS) {
      if (!isTunnelRow(r)) return;
      c = (c + COLS) % COLS;
    }
    grid[r][c] = v;
  }

  function isWall(r, c){
    return tileAt(r, c) === 1;
  }

  function isCenteredOnTile(entity){
    const cx = entity.x % TILE;
    const cy = entity.y % TILE;
    const eps = 1.2;
    return Math.abs(cx - TILE/2) < eps && Math.abs(cy - TILE/2) < eps;
  }

  // --- Spawns ---
  const PAC_SPAWN = { r: 17, c: 12 }; // walkable in your map
  const GHOST_SPAWNS = [
    { r: 12, c: 13 },
    { r: 12, c: 14 },
    { r: 12, c: 15 },
    { r: 12, c: 14 },
  ];

  // "Door" above the ghost house:
  // We mark these as walkable pellets so ghosts reliably exit.
  const GHOST_DOOR = [{ r: 11, c: 13 }, { r: 11, c: 14 }];

  // --- Game state ---
  let running = false;
  let gameOver = false;
  let score = 0;
  let lives = 3;
  let gameTime = 0;

  const DIRS = {
    LEFT:  { x:-1, y: 0 },
    RIGHT: { x: 1, y: 0 },
    UP:    { x: 0, y:-1 },
    DOWN:  { x: 0, y: 1 },
    NONE:  { x: 0, y: 0 },
  };

  const pac = {
    x: 0, y: 0,
    dir: DIRS.NONE,
    nextDir: DIRS.NONE,
    speed: 120,
    radius: TILE * 0.42,
  };

  const ghosts = [
    { x:0,y:0, dir:DIRS.LEFT,  speed:105, color:"#ff3b30", inHouse:true, releaseAt:0 },
    { x:0,y:0, dir:DIRS.RIGHT, speed:100, color:"#34c759", inHouse:true, releaseAt:0 },
    { x:0,y:0, dir:DIRS.UP,    speed: 98, color:"#0a84ff", inHouse:true, releaseAt:0 },
    { x:0,y:0, dir:DIRS.DOWN,  speed:102, color:"#ff9f0a", inHouse:true, releaseAt:0 },
  ];

  function findNearestWalkable(sr, sc){
    const q = [{r:sr, c:sc}];
    const seen = new Set([`${sr},${sc}`]);
    const ok = (r,c) => r>=0 && r<ROWS && c>=0 && c<COLS;
    const walk = (r,c) => grid[r][c] !== 1;

    while (q.length) {
      const cur = q.shift();
      if (walk(cur.r, cur.c)) return cur;
      for (const [dr,dc] of [[1,0],[-1,0],[0,1],[0,-1]]) {
        const nr = cur.r + dr, nc = cur.c + dc;
        const key = `${nr},${nc}`;
        if (!ok(nr,nc) || seen.has(key)) continue;
        seen.add(key);
        q.push({r:nr, c:nc});
      }
    }
    return {r:1,c:1};
  }

  function resetPositions(){
    const p = centerOf(PAC_SPAWN.r, PAC_SPAWN.c);
    pac.x = p.x; pac.y = p.y;
    pac.dir = DIRS.NONE;
    pac.nextDir = DIRS.NONE;

    // safety: if pac spawn ever becomes wall, fix
    if (isWall(tileRow(pac.y), tileCol(pac.x))) {
      const fix = findNearestWalkable(PAC_SPAWN.r, PAC_SPAWN.c);
      const cc = centerOf(fix.r, fix.c);
      pac.x = cc.x; pac.y = cc.y;
    }

    ghosts.forEach((g, i) => {
      const s = GHOST_SPAWNS[i] || GHOST_SPAWNS[0];
      const c = centerOf(s.r, s.c);
      g.x = c.x + (i - 1.5) * 3;
      g.y = c.y + (i % 2 ? 3 : -3);
      g.dir = [DIRS.LEFT, DIRS.RIGHT, DIRS.UP, DIRS.DOWN][i % 4];
      g.inHouse = true;
      g.releaseAt = gameTime + (i * 0.9); // staggered release
    });

    // safety for ghosts
    ghosts.forEach(g => {
      if (isWall(tileRow(g.y), tileCol(g.x))) {
        const fix = findNearestWalkable(12, 14);
        const cc = centerOf(fix.r, fix.c);
        g.x = cc.x; g.y = cc.y;
      }
    });
  }

  function resetGame(full=false){
    if (full) {
      for (let r=0;r<ROWS;r++){
        for (let c=0;c<COLS;c++){
          grid[r][c] = Number(MAP[r][c]);
        }
      }
      score = 0;
      lives = 3;
      gameTime = 0;
    }

    // ensure ghost door is open (walkable)
    for (const d of GHOST_DOOR) {
      if (tileAt(d.r, d.c) === 1) setTile(d.r, d.c, 2);
    }

    gameOver = false;
    running = false;
    statusEl.textContent = "Ready";
    scoreEl.textContent = score;
    livesEl.textContent = lives;
    resetPositions();
    draw();
  }

  // --- Robust collision: circle vs tile grid ---
  function hitsWallAt(x, y, radius){
    const r0 = tileRow(y - radius);
    const r1 = tileRow(y + radius);
    const c0 = tileCol(x - radius);
    const c1 = tileCol(x + radius);

    // sample 4 corners of the circle's bounding box (works great for these sprites)
    const pts = [
      {r:r0, c:c0}, {r:r0, c:c1},
      {r:r1, c:c0}, {r:r1, c:c1},
    ];

    for (const p of pts) {
      let rr = p.r;
      let cc = p.c;

      if (rr < 0 || rr >= ROWS) return true;

      // only wrap columns if tunnel row
      if (cc < 0 || cc >= COLS) {
        if (!isTunnelRow(rr)) return true;
        cc = (cc + COLS) % COLS;
      }
      if (isWall(rr, cc)) return true;
    }
    return false;
  }

  // Move with axis separation so you never get embedded in walls.
  function moveEntity(entity, dt){
    if (entity.dir === DIRS.NONE) return false;

    const r = entity.radius ?? (TILE * 0.40);

    // --- X move ---
    let nx = entity.x + entity.dir.x * entity.speed * dt;
    let ny = entity.y;

    // tunnel wrap only if current row is tunnel row
    nx = wrapXIfTunnel(tileRow(ny), nx);

    if (!hitsWallAt(nx, ny, r * 0.95)) {
      entity.x = nx;
    } else {
      // snap out: align to nearest safe edge
      // If moving right, snap to left edge of next wall tile; if left, snap to right edge
      const curR = tileRow(entity.y);
      const curC = tileCol(entity.x);
      const center = centerOf(curR, curC);
      entity.x = center.x;
      // stop horizontal motion
      if (entity.dir.x !== 0) entity.dir = (entity === pac) ? DIRS.NONE : entity.dir;
      // ghosts keep their dir; AI will change next center
      if (entity !== pac) entity.dir = { x: 0, y: entity.dir.y };
    }

    // --- Y move ---
    nx = entity.x;
    ny = entity.y + entity.dir.y * entity.speed * dt;

    if (!hitsWallAt(nx, ny, r * 0.95)) {
      entity.y = ny;
    } else {
      const curR = tileRow(entity.y);
      const curC = tileCol(entity.x);
      const center = centerOf(curR, curC);
      entity.y = center.y;
      if (entity.dir.y !== 0) entity.dir = (entity === pac) ? DIRS.NONE : entity.dir;
      if (entity !== pac) entity.dir = { x: entity.dir.x, y: 0 };
    }

    // final wrap (in case x changed row mid-step)
    entity.x = wrapXIfTunnel(tileRow(entity.y), entity.x);
    return true;
  }

  function tryTurnPac(){
    if (pac.nextDir === DIRS.NONE) return;
    if (!isCenteredOnTile(pac)) return;

    const testX = pac.x + pac.nextDir.x * TILE * 0.55;
    const testY = pac.y + pac.nextDir.y * TILE * 0.55;

    const r = pac.radius * 0.95;
    const tx = wrapXIfTunnel(tileRow(testY), testX);

    if (!hitsWallAt(tx, testY, r)) pac.dir = pac.nextDir;
  }

  function eat(){
    const r = tileRow(pac.y);
    const c = tileCol(pac.x);
    const t = tileAt(r, c);

    if (t === 2) { setTile(r, c, 0); score += 10; }
    if (t === 3) { setTile(r, c, 0); score += 50; }
    scoreEl.textContent = score;
  }

  function collide(a, b){
    const dx = a.x - b.x;
    const dy = a.y - b.y;
    return Math.hypot(dx, dy) < TILE * 0.55;
  }

  function ghostAI(g){
    // Ghost release logic: get them out of the house first.
    if (g.inHouse) {
      if (gameTime < g.releaseAt) {
        // idle wiggle inside house
        if (isCenteredOnTile(g) && Math.random() < 0.25) {
          g.dir = [DIRS.LEFT, DIRS.RIGHT][Math.random() < 0.5 ? 0 : 1];
        }
        return;
      }

      // head to door center
      const door = centerOf(GHOST_DOOR[1].r, GHOST_DOOR[1].c);
      const dx = door.x - g.x;
      const dy = door.y - g.y;

      if (Math.abs(dx) > Math.abs(dy)) {
        g.dir = dx > 0 ? DIRS.RIGHT : DIRS.LEFT;
      } else {
        g.dir = dy > 0 ? DIRS.DOWN : DIRS.UP;
      }

      // once above the house area, switch to normal AI
      if (tileRow(g.y) <= GHOST_DOOR[1].r) {
        // if they've reached the door row and are not inside 4's anymore, release them
        const tr = tileRow(g.y);
        const tc = tileCol(g.x);
        if (tileAt(tr, tc) !== 4) g.inHouse = false;
      }
      return;
    }

    // normal chase-ish turning at intersections
    if (!isCenteredOnTile(g)) return;

    const options = [DIRS.LEFT, DIRS.RIGHT, DIRS.UP, DIRS.DOWN].filter(d => {
      const reverse = (d.x === -g.dir.x && d.y === -g.dir.y);
      if (reverse) return false;

      const tx = wrapXIfTunnel(tileRow(g.y), g.x + d.x * TILE * 0.55);
      const ty = g.y + d.y * TILE * 0.55;

      return !hitsWallAt(tx, ty, TILE * 0.38);
    });

    if (options.length === 0) {
      g.dir = { x:-g.dir.x, y:-g.dir.y };
      return;
    }

    let best = options[0];
    let bestScore = Infinity;
    for (const d of options) {
      const tx = wrapXIfTunnel(tileRow(g.y), g.x + d.x * TILE);
      const ty = g.y + d.y * TILE;
      const s = Math.hypot(pac.x - tx, pac.y - ty);
      if (s < bestScore) { bestScore = s; best = d; }
    }

    g.dir = (Math.random() < 0.18)
      ? options[Math.floor(Math.random() * options.length)]
      : best;
  }

  // --- Rendering ---
  let last = performance.now();
  let perfNow = last;
  let accumulator = 0;
  const FIXED = 1/120;

  function dirToAngle(d){
    if (d === DIRS.RIGHT) return 0;
    if (d === DIRS.LEFT) return Math.PI;
    if (d === DIRS.UP) return -Math.PI/2;
    if (d === DIRS.DOWN) return Math.PI/2;
    return 0;
  }

  function drawGhost(g){
    const r = TILE * 0.42;
    const x = g.x, y = g.y;

    ctx.fillStyle = g.color;
    ctx.beginPath();
    ctx.arc(x, y, r, Math.PI, 0);
    ctx.lineTo(x + r, y + r);
    for (let i=0;i<6;i++){
      const px = x + r - (i*(2*r/5));
      const py = y + r - (i%2 ? 4 : 0);
      ctx.lineTo(px, py);
    }
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = "#fff";
    ctx.beginPath();
    ctx.arc(x - r*0.35, y - r*0.15, r*0.22, 0, Math.PI*2);
    ctx.arc(x + r*0.35, y - r*0.15, r*0.22, 0, Math.PI*2);
    ctx.fill();

    const pdx = g.dir.x * 2.2;
    const pdy = g.dir.y * 2.2;
    ctx.fillStyle = "#111";
    ctx.beginPath();
    ctx.arc(x - r*0.35 + pdx, y - r*0.15 + pdy, r*0.10, 0, Math.PI*2);
    ctx.arc(x + r*0.35 + pdx, y - r*0.15 + pdy, r*0.10, 0, Math.PI*2);
    ctx.fill();
  }

  function overlayText(text){
    ctx.fillStyle = "rgba(0,0,0,0.55)";
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = "#e6edf7";
    ctx.font = "700 34px ui-sans-serif, system-ui";
    ctx.textAlign = "center";
    ctx.fillText(text, canvas.width/2, canvas.height/2);
    ctx.font = "500 16px ui-sans-serif, system-ui";
    ctx.fillStyle = "rgba(230,237,247,0.8)";
    ctx.fillText("Use arrow keys / WASD", canvas.width/2, canvas.height/2 + 28);
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);

    for (let r=0;r<ROWS;r++){
      for (let c=0;c<COLS;c++){
        const t = grid[r][c];
        const x = c*TILE, y = r*TILE;

        if (t === 1) {
          ctx.fillStyle = "#0a2a8a";
          ctx.fillRect(x, y, TILE, TILE);
        } else {
          ctx.fillStyle = "#050a12";
          ctx.fillRect(x, y, TILE, TILE);

          ctx.strokeStyle = "rgba(255,255,255,0.035)";
          ctx.strokeRect(x, y, TILE, TILE);

          if (t === 2) {
            ctx.fillStyle = "#ffd60a";
            ctx.beginPath();
            ctx.arc(x+TILE/2, y+TILE/2, 2.2, 0, Math.PI*2);
            ctx.fill();
          }
          if (t === 3) {
            ctx.fillStyle = "#ffd60a";
            ctx.beginPath();
            ctx.arc(x+TILE/2, y+TILE/2, 5.0, 0, Math.PI*2);
            ctx.fill();
          }
          if (t === 4) {
            ctx.fillStyle = "rgba(255,255,255,0.05)";
            ctx.fillRect(x, y, TILE, TILE);
          }
        }
      }
    }

    // Pac-Man
    const mouth = running ? (0.25 + 0.15*Math.sin(perfNow/90)) : 0.25;
    ctx.fillStyle = "#ffd60a";
    ctx.beginPath();
    const angle = dirToAngle(pac.dir);
    ctx.moveTo(pac.x, pac.y);
    ctx.arc(pac.x, pac.y, pac.radius, angle + mouth, angle + Math.PI*2 - mouth);
    ctx.closePath();
    ctx.fill();

    ghosts.forEach(g => drawGhost(g));

    if (!running && !gameOver) overlayText("Press Start");
    if (gameOver) overlayText("Game Over");
  }

  // --- Input ---
  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();
    if (k === "arrowleft" || k === "a") pac.nextDir = DIRS.LEFT;
    if (k === "arrowright" || k === "d") pac.nextDir = DIRS.RIGHT;
    if (k === "arrowup" || k === "w") pac.nextDir = DIRS.UP;
    if (k === "arrowdown" || k === "s") pac.nextDir = DIRS.DOWN;
  });

  startBtn.addEventListener("click", () => {
    if (gameOver) resetGame(false);
    running = true;
    statusEl.textContent = "Playing";
  });

  resetBtn.addEventListener("click", () => resetGame(true));

  // --- Loop ---
  function tick(now){
    perfNow = now;
    const dt = Math.min(0.05, (now - last) / 1000);
    last = now;
    accumulator += dt;

    while (accumulator >= FIXED) {
      if (running && !gameOver) update(FIXED);
      accumulator -= FIXED;
    }

    draw();
    requestAnimationFrame(tick);
  }

  function update(dt){
    gameTime += dt;

    // pac turn + move
    tryTurnPac();
    if (pac.dir !== DIRS.NONE) {
      const moved = moveEntity(pac, dt);
      if (!moved) pac.dir = DIRS.NONE;
    }

    // eat pellets
    eat();

    // ghosts
    for (const g of ghosts) {
      ghostAI(g);
      moveEntity(g, dt);

      if (collide(pac, g)) {
        lives--;
        livesEl.textContent = lives;
        if (lives <= 0) {
          running = false;
          gameOver = true;
          statusEl.textContent = "Game Over";
        } else {
          running = false;
          statusEl.textContent = "Ready";
          resetPositions();
        }
        break;
      }
    }
  }

  // init
  resetGame(true);
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
