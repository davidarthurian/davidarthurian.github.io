<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Fun | Pac-Man</title>
  <style>
    :root{
      --bg:#0b1220;
      --panel:#0f1a2e;
      --text:#e6edf7;
      --muted:#9fb0c6;
      --border:rgba(255,255,255,0.10);
      --btn: rgba(255,255,255,0.05);
      --btnHover: rgba(255,255,255,0.08);
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      min-height:100vh;
      display:flex;
      justify-content:center;
      align-items:center;
      padding: 18px;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background:
        radial-gradient(900px 600px at 80% 10%, rgba(125,211,252,0.12), transparent 60%),
        radial-gradient(900px 600px at 20% 90%, rgba(167,139,250,0.10), transparent 60%),
        var(--bg);
      color: var(--text);
    }
    .wrap{
      width:min(980px, 100%);
      border:1px solid var(--border);
      background: rgba(15,26,46,0.55);
      border-radius: 18px;
      padding: 14px;
      box-shadow: 0 18px 60px rgba(0,0,0,0.35);
    }
    .top{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap: 12px;
      flex-wrap:wrap;
      margin-bottom: 12px;
    }
    .title{
      font-weight: 900;
      letter-spacing: -0.2px;
    }
    .hud{
      display:flex;
      gap: 10px;
      flex-wrap:wrap;
      align-items:center;
      color: var(--muted);
      font-size: 0.95rem;
    }
    .pill{
      border:1px solid var(--border);
      background: rgba(255,255,255,0.03);
      border-radius: 999px;
      padding: 6px 10px;
      white-space:nowrap;
    }
    .btn{
      border:1px solid var(--border);
      background: var(--btn);
      color: var(--text);
      border-radius: 12px;
      padding: 10px 12px;
      font-weight: 800;
      cursor:pointer;
    }
    .btn:hover{ background: var(--btnHover); }

    .layout{
      display:grid;
      grid-template-columns: 1fr 260px;
      gap: 12px;
      align-items:start;
    }

    .panel{
      border:1px solid var(--border);
      background: rgba(255,255,255,0.03);
      border-radius: 16px;
      padding: 12px;
    }

    canvas{
      width: 100%;
      height: auto;
      display:block;
      border-radius: 14px;
      border:1px solid var(--border);
      background: #000;
    }

    .help{
      color: var(--muted);
      font-size: 0.95rem;
      line-height: 1.35;
      margin-top: 10px;
    }

    /* Mobile D-pad */
    .dpad{
      margin-top: 12px;
      display:grid;
      grid-template-columns: 64px 64px 64px;
      grid-template-rows: 64px 64px 64px;
      gap: 8px;
      justify-content:center;
      user-select:none;
      touch-action: manipulation;
    }
    .dpad button{
      border:1px solid var(--border);
      background: rgba(255,255,255,0.04);
      color: var(--text);
      border-radius: 14px;
      font-weight: 900;
      font-size: 18px;
      cursor:pointer;
    }
    .dpad button:active{
      transform: translateY(1px);
      background: rgba(255,255,255,0.08);
    }
    .dpad .empty{ visibility:hidden; }

    @media (max-width: 860px){
      .layout{ grid-template-columns: 1fr; }
      .dpad{ grid-template-columns: 70px 70px 70px; grid-template-rows: 70px 70px 70px; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <div class="title">Pac-Man (classic-style)</div>
      <div class="hud">
        <span class="pill">Score: <b id="score">0</b></span>
        <span class="pill">Lives: <b id="lives">3</b></span>
        <span class="pill">Status: <b id="status">Ready</b></span>
        <button class="btn" id="start">Start</button>
        <button class="btn" id="reset">Reset</button>
      </div>
    </div>

    <div class="layout">
      <div class="panel">
        <canvas id="game" width="672" height="744" aria-label="Pac-Man game"></canvas>
      </div>

      <div class="panel">
        <div style="font-weight:900;margin-bottom:8px;">Controls</div>
        <div class="help">
          Desktop: Arrow keys / WASD<br/>
          Mobile: Use the D-pad below<br/>
          Tunnel wrap works like OG (left/right).
        </div>

        <div class="dpad" aria-label="Mobile controls">
          <button class="empty"></button>
          <button id="up">â–²</button>
          <button class="empty"></button>
          <button id="left">â—€</button>
          <button id="down">â–¼</button>
          <button id="right">â–¶</button>
          <button class="empty"></button>
          <button class="empty"></button>
          <button class="empty"></button>
        </div>

        <div class="help" style="margin-top:12px;">
          Power pellets turn ghosts blue for a short time. Eat them for bonus points.
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  const scoreEl = document.getElementById("score");
  const livesEl = document.getElementById("lives");
  const statusEl = document.getElementById("status");
  const startBtn = document.getElementById("start");
  const resetBtn = document.getElementById("reset");

  // ======= Maze (classic-inspired) =======
  // 0 empty, 1 wall, 2 pellet, 3 power pellet, 4 ghost door (treated as wall for pac)
  // This is intentionally "OG-feel" rather than a perfect ROM-accurate maze.
  const MAP = [
    "1111111111111111111111111111",
    "1222222222222112222222222221",
    "1211112111112112111112111121",
    "1311112111112112111112111131",
    "1211112111112112111112111121",
    "1222222222222222222222222221",
    "1211112112111111112112111121",
    "1211112112111111112112111121",
    "1222222112222112222112222221",
    "1111112111112112111112111111",
    "0000012111112112111112100000",
    "1111112112111111112112111111",
    "2222222222114444112222222222",
    "1111112112111111112112111111",
    "0000012111112112111112100000",
    "1111112112111111112112111111",
    "1222222222222112222222222221",
    "1211112111112112111112111121",
    "1311122222222222222222111131",
    "1111122112111111112112111111",
    "1222222112111111112112222221",
    "1211111112222112222111111121",
    "1211111111112112111111111121",
    "1222222222222222222222222221",
    "1111111111111111111111111111",
  ].map(row => row.split("").map(c => Number(c)));

  const rows = MAP.length;
  const cols = MAP[0].length;

  const TILE = 24;             // px
  const W = cols * TILE;
  const H = rows * TILE;
  canvas.width = W;
  canvas.height = H;

  // Tunnel wrap row: pick the row that has the "00000" side corridors
  // In this map, rows 10 and 14 have side tunnels; weâ€™ll allow wrapping if y is close to their center.
  const tunnelRows = new Set([10, 14]);

  // ======= Game params (smooth) =======
  const FIXED_DT = 1/120;      // simulate at 120Hz (smooth without choppy tick changes)
  let accumulator = 0;
  let lastT = 0;

  const PAC_SPEED = 110;       // px/s
  const GHOST_SPEED = 95;      // px/s
  const FRIGHT_SPEED = 75;     // px/s
  const TURN_EPS = 0.12;       // how close to center to allow turning (tiles)

  let running = false;
  let paused = true;

  let score = 0;
  let lives = 3;

  // pellets count for win
  function countPellets(){
    let n = 0;
    for (let r=0;r<rows;r++){
      for (let c=0;c<cols;c++){
        if (MAP[r][c] === 2 || MAP[r][c] === 3) n++;
      }
    }
    return n;
  }
  let pelletsLeft = countPellets();

  // Directions
  const DIRS = {
    left:  {x:-1, y: 0, a: Math.PI},
    right: {x: 1, y: 0, a: 0},
    up:    {x: 0, y:-1, a: -Math.PI/2},
    down:  {x: 0, y: 1, a: Math.PI/2},
    none:  {x: 0, y: 0, a: 0},
  };

  function tileAt(px, py){
    const c = Math.floor(px / TILE);
    const r = Math.floor(py / TILE);
    if (r < 0 || r >= rows || c < 0 || c >= cols) return 1;
    return MAP[r][c];
  }
  function isWallTile(val){ return val === 1; }
  function isGhostDoor(val){ return val === 4; }

  function canMoveTo(px, py, forGhost=false){
    const val = tileAt(px, py);
    if (isWallTile(val)) return false;
    if (!forGhost && isGhostDoor(val)) return false;
    return true;
  }

  function centerOfTile(r,c){
    return { x: c*TILE + TILE/2, y: r*TILE + TILE/2 };
  }

  function clampWrap(entity){
    // wrap only on tunnel rows and only when leaving left/right bounds
    const r = Math.floor(entity.y / TILE);
    if (!tunnelRows.has(r)) return;

    if (entity.x < -TILE/2) entity.x = W + TILE/2;
    if (entity.x > W + TILE/2) entity.x = -TILE/2;
  }

  function nearCenter(entity){
    const c = Math.floor(entity.x / TILE);
    const r = Math.floor(entity.y / TILE);
    const ctr = centerOfTile(r,c);
    const dx = Math.abs(entity.x - ctr.x) / TILE;
    const dy = Math.abs(entity.y - ctr.y) / TILE;
    return (dx < TURN_EPS && dy < TURN_EPS);
  }

  // ======= Entities =======
  const pac = {
    x: 14*TILE + TILE/2,
    y: 17*TILE + TILE/2,
    dir: DIRS.left,
    want: DIRS.left,
    mouthT: 0,
  };

  const ghosts = [
    { name:"Blinky", color:"#ff3b3b", x: 14*TILE+TILE/2, y: 12*TILE+TILE/2, dir: DIRS.left,  mode:"chase", fright:0 },
    { name:"Pinky",  color:"#ff7bd0", x: 13*TILE+TILE/2, y: 12*TILE+TILE/2, dir: DIRS.right, mode:"chase", fright:0 },
    { name:"Inky",   color:"#46e8ff", x: 15*TILE+TILE/2, y: 12*TILE+TILE/2, dir: DIRS.left,  mode:"chase", fright:0 },
    { name:"Clyde",  color:"#ffb347", x: 14*TILE+TILE/2, y: 13*TILE+TILE/2, dir: DIRS.right, mode:"chase", fright:0 },
  ];

  // ======= Input =======
  function setWant(dir){
    pac.want = dir;
  }
  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();
    if (k === "arrowleft" || k === "a") setWant(DIRS.left);
    if (k === "arrowright"|| k === "d") setWant(DIRS.right);
    if (k === "arrowup"   || k === "w") setWant(DIRS.up);
    if (k === "arrowdown" || k === "s") setWant(DIRS.down);
  });

  // mobile buttons
  document.getElementById("up").addEventListener("click", () => setWant(DIRS.up));
  document.getElementById("down").addEventListener("click", () => setWant(DIRS.down));
  document.getElementById("left").addEventListener("click", () => setWant(DIRS.left));
  document.getElementById("right").addEventListener("click", () => setWant(DIRS.right));

  // ======= Start/Reset =======
  function setStatus(s){ statusEl.textContent = s; }
  function updateHUD(){
    scoreEl.textContent = score;
    livesEl.textContent = lives;
  }

  function resetPositions(){
    pac.x = 14*TILE + TILE/2;
    pac.y = 17*TILE + TILE/2;
    pac.dir = DIRS.left;
    pac.want = DIRS.left;
    pac.mouthT = 0;

    ghosts[0].x = 14*TILE+TILE/2; ghosts[0].y = 12*TILE+TILE/2; ghosts[0].dir = DIRS.left;
    ghosts[1].x = 13*TILE+TILE/2; ghosts[1].y = 12*TILE+TILE/2; ghosts[1].dir = DIRS.right;
    ghosts[2].x = 15*TILE+TILE/2; ghosts[2].y = 12*TILE+TILE/2; ghosts[2].dir = DIRS.left;
    ghosts[3].x = 14*TILE+TILE/2; ghosts[3].y = 13*TILE+TILE/2; ghosts[3].dir = DIRS.right;

    ghosts.forEach(g => { g.fright = 0; g.mode = "chase"; });
  }

  function hardReset(){
    // restore pellets
    const original = [
      "1111111111111111111111111111",
      "1222222222222112222222222221",
      "1211112111112112111112111121",
      "1311112111112112111112111131",
      "1211112111112112111112111121",
      "1222222222222222222222222221",
      "1211112112111111112112111121",
      "1211112112111111112112111121",
      "1222222112222112222112222221",
      "1111112111112112111112111111",
      "0000012111112112111112100000",
      "1111112112111111112112111111",
      "2222222222114444112222222222",
      "1111112112111111112112111111",
      "0000012111112112111112100000",
      "1111112112111111112112111111",
      "1222222222222112222222222221",
      "1211112111112112111112111121",
      "1311122222222222222222111131",
      "1111122112111111112112111111",
      "1222222112111111112112222221",
      "1211111112222112222111111121",
      "1211111111112112111111111121",
      "1222222222222222222222222221",
      "1111111111111111111111111111",
    ].map(row => row.split("").map(c => Number(c)));
    for (let r=0;r<rows;r++){
      for (let c=0;c<cols;c++){
        MAP[r][c] = original[r][c];
      }
    }
    pelletsLeft = countPellets();
    score = 0;
    lives = 3;
    updateHUD();
    resetPositions();
    setStatus("Ready");
    paused = true;
    running = false;
  }

  startBtn.addEventListener("click", () => {
    if (!running){
      running = true;
      paused = false;
      setStatus("Playing");
      lastT = performance.now()/1000;
      requestAnimationFrame(frame);
    } else if (paused){
      paused = false;
      setStatus("Playing");
    }
  });

  resetBtn.addEventListener("click", () => {
    hardReset();
    draw(); // refresh
  });

  // ======= Movement + AI =======
  function tryTurn(entity, wantDir, forGhost=false){
    if (!nearCenter(entity)) return false;

    const nx = entity.x + wantDir.x * (TILE/2);
    const ny = entity.y + wantDir.y * (TILE/2);

    if (canMoveTo(nx, ny, forGhost)){
      entity.dir = wantDir;
      // snap to center to avoid drift
      const c = Math.floor(entity.x / TILE);
      const r = Math.floor(entity.y / TILE);
      const ctr = centerOfTile(r,c);
      entity.x = ctr.x;
      entity.y = ctr.y;
      return true;
    }
    return false;
  }

  function moveEntity(entity, speed, dt, forGhost=false){
    // attempt to turn
    if (!forGhost) tryTurn(entity, pac.want, false);

    const dx = entity.dir.x * speed * dt;
    const dy = entity.dir.y * speed * dt;

    const nx = entity.x + dx;
    const ny = entity.y + dy;

    // collision check along movement axis
    if (canMoveTo(nx, ny, forGhost)){
      entity.x = nx;
      entity.y = ny;
    } else {
      // if blocked, snap to center and stop (or for ghosts choose another direction)
      if (nearCenter(entity)){
        const c = Math.floor(entity.x / TILE);
        const r = Math.floor(entity.y / TILE);
        const ctr = centerOfTile(r,c);
        entity.x = ctr.x;
        entity.y = ctr.y;
      }
    }

    clampWrap(entity);
  }

  function choicesForGhost(g){
    const dirs = [DIRS.up, DIRS.down, DIRS.left, DIRS.right];
    const opts = [];
    for (const d of dirs){
      // prevent reversing unless stuck
      const reverse = (d.x === -g.dir.x && d.y === -g.dir.y);
      const nx = g.x + d.x*(TILE/2);
      const ny = g.y + d.y*(TILE/2);
      if (!canMoveTo(nx, ny, true)) continue;
      opts.push({d, reverse});
    }
    if (!opts.length) return [];
    const nonReverse = opts.filter(o => !o.reverse);
    return nonReverse.length ? nonReverse : opts;
  }

  function dist2(ax,ay,bx,by){
    const dx = ax-bx, dy = ay-by;
    return dx*dx + dy*dy;
  }

  function ghostTarget(g){
    // Simple â€œclassic-ishâ€ behavior:
    // - Blinky: target Pac directly
    // - Pinky: target 4 tiles ahead
    // - Inky: target 2 tiles ahead (lite)
    // - Clyde: if close, scatter to corner; else chase Pac
    const ahead = (n) => ({
      x: pac.x + pac.dir.x * TILE * n,
      y: pac.y + pac.dir.y * TILE * n
    });

    if (g.fright > 0) return null; // frightened: random

    if (g.name === "Blinky") return {x: pac.x, y: pac.y};
    if (g.name === "Pinky")  return ahead(4);
    if (g.name === "Inky")   return ahead(2);
    if (g.name === "Clyde"){
      const d = Math.sqrt(dist2(g.x,g.y,pac.x,pac.y));
      if (d < TILE*6) return {x: 1*TILE, y: (rows-2)*TILE}; // scatter-ish
      return {x: pac.x, y: pac.y};
    }
    return {x: pac.x, y: pac.y};
  }

  function updateGhostDir(g){
    if (!nearCenter(g)) return;

    const opts = choicesForGhost(g);
    if (!opts.length) return;

    if (g.fright > 0){
      // random-ish choice
      const pick = opts[Math.floor(Math.random()*opts.length)];
      g.dir = pick.d;
      return;
    }

    const tgt = ghostTarget(g);
    if (!tgt){
      const pick = opts[Math.floor(Math.random()*opts.length)];
      g.dir = pick.d;
      return;
    }

    // choose direction that minimizes distance to target
    let best = opts[0].d;
    let bestD = Infinity;
    for (const o of opts){
      const d = o.d;
      const nx = g.x + d.x * TILE;
      const ny = g.y + d.y * TILE;
      const dd = dist2(nx,ny,tgt.x,tgt.y);
      if (dd < bestD){
        bestD = dd;
        best = d;
      }
    }
    g.dir = best;
  }

  // ======= Eating + collisions =======
  function eatPellet(){
    const c = Math.floor(pac.x / TILE);
    const r = Math.floor(pac.y / TILE);
    if (r<0||r>=rows||c<0||c>=cols) return;

    const v = MAP[r][c];
    if (v === 2){
      MAP[r][c] = 0;
      pelletsLeft--;
      score += 10;
    } else if (v === 3){
      MAP[r][c] = 0;
      pelletsLeft--;
      score += 50;
      // frighten ghosts
      ghosts.forEach(g => g.fright = 7.0); // seconds
    }
  }

  function collide(a,b){
    const rr = TILE*0.42;
    return dist2(a.x,a.y,b.x,b.y) < rr*rr;
  }

  function handleGhostCollisions(){
    for (const g of ghosts){
      if (!collide(pac,g)) continue;

      if (g.fright > 0){
        // eat ghost
        score += 200;
        g.fright = 0;
        // send back to house-ish
        g.x = 14*TILE+TILE/2;
        g.y = 12*TILE+TILE/2;
        g.dir = DIRS.left;
      } else {
        // lose life
        lives--;
        updateHUD();
        if (lives <= 0){
          setStatus("Game Over");
          paused = true;
          running = false;
          alert("Game Over");
          return;
        } else {
          setStatus("Ouch!");
          paused = true;
          running = false;
          alert("You got caught! Press Start to continue.");
          resetPositions();
          setStatus("Ready");
          return;
        }
      }
    }
  }

  // ======= Simulation step =======
  function step(dt){
    // pac
    moveEntity(pac, PAC_SPEED, dt, false);
    eatPellet();

    // ghosts
    for (const g of ghosts){
      // fright timer
      if (g.fright > 0){
        g.fright = Math.max(0, g.fright - dt);
      }
      updateGhostDir(g);
      const sp = (g.fright > 0) ? FRIGHT_SPEED : GHOST_SPEED;
      moveEntity(g, sp, dt, true);
    }

    handleGhostCollisions();

    if (pelletsLeft <= 0){
      setStatus("You Win!");
      paused = true;
      running = false;
      alert("You cleared the board! ðŸŽ‰");
    }
  }

  // ======= Drawing =======
  function drawMaze(){
    // background
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,W,H);

    // walls
    ctx.lineWidth = 3;
    for (let r=0;r<rows;r++){
      for (let c=0;c<cols;c++){
        const v = MAP[r][c];
        const x = c*TILE;
        const y = r*TILE;

        if (v === 1){
          ctx.fillStyle = "#102a83"; // blue-ish
          ctx.fillRect(x,y,TILE,TILE);
          // inner border for OG feel
          ctx.strokeStyle = "rgba(0,0,0,0.25)";
          ctx.strokeRect(x+1.5,y+1.5,TILE-3,TILE-3);
        } else if (v === 4){
          // ghost door
          ctx.fillStyle = "rgba(255,255,255,0.12)";
          ctx.fillRect(x,y,TILE,TILE);
        }
      }
    }

    // pellets & power pellets
    for (let r=0;r<rows;r++){
      for (let c=0;c<cols;c++){
        const v = MAP[r][c];
        const cx = c*TILE + TILE/2;
        const cy = r*TILE + TILE/2;

        if (v === 2){
          ctx.fillStyle = "#f5f5f5";
          ctx.beginPath();
          ctx.arc(cx,cy,2.6,0,Math.PI*2);
          ctx.fill();
        } else if (v === 3){
          // pulsing
          const t = performance.now()/1000;
          const rad = 6 + Math.sin(t*6)*1.5;
          ctx.fillStyle = "#f5f5f5";
          ctx.beginPath();
          ctx.arc(cx,cy,rad,0,Math.PI*2);
          ctx.fill();
        }
      }
    }
  }

  function drawPac(){
    const t = performance.now()/1000;
    // mouth animation (0..1)
    pac.mouthT = 0.5 + 0.5*Math.sin(t*10);
    const mouth = 0.2 + pac.mouthT*0.35;

    const angle = pac.dir.a;
    const r = TILE*0.42;

    ctx.save();
    ctx.translate(pac.x, pac.y);
    ctx.rotate(angle);

    ctx.fillStyle = "#ffd000";
    ctx.beginPath();
    ctx.moveTo(0,0);
    ctx.arc(0,0,r,mouth*Math.PI,(2 - mouth)*Math.PI);
    ctx.closePath();
    ctx.fill();

    ctx.restore();
  }

  function drawGhost(g){
    const r = TILE*0.42;
    const bob = Math.sin((performance.now()/1000)*8 + g.x*0.01)*1.2;

    const frightened = (g.fright > 0);
    const body = frightened ? "#2b6cff" : g.color;

    ctx.save();
    ctx.translate(g.x, g.y + bob);

    // body (rounded top + wavy bottom)
    ctx.fillStyle = body;
    ctx.beginPath();
    ctx.arc(0, -r*0.15, r, Math.PI, 0, false);

    // sides down
    ctx.lineTo(r, r*0.95);

    // wavy bottom
    const waveCount = 4;
    for (let i=0;i<waveCount;i++){
      const wx = r - (i+1)*(2*r/waveCount);
      ctx.quadraticCurveTo(wx + (r/waveCount), r*0.70, wx, r*0.95);
    }
    ctx.lineTo(-r, r*0.95);
    ctx.closePath();
    ctx.fill();

    // eyes
    if (!frightened){
      const eyeX = r*0.35;
      const eyeY = -r*0.05;

      ctx.fillStyle = "#fff";
      ctx.beginPath();
      ctx.ellipse(-eyeX, eyeY, r*0.22, r*0.28, 0, 0, Math.PI*2);
      ctx.ellipse( eyeX, eyeY, r*0.22, r*0.28, 0, 0, Math.PI*2);
      ctx.fill();

      // pupils follow direction
      const px = g.dir.x * r*0.10;
      const py = g.dir.y * r*0.10;

      ctx.fillStyle = "#1b2a4a";
      ctx.beginPath();
      ctx.arc(-eyeX + px, eyeY + py, r*0.10, 0, Math.PI*2);
      ctx.arc( eyeX + px, eyeY + py, r*0.10, 0, Math.PI*2);
      ctx.fill();
    } else {
      // frightened face
      ctx.fillStyle = "#fff";
      ctx.beginPath();
      ctx.arc(-r*0.25, -r*0.05, r*0.10, 0, Math.PI*2);
      ctx.arc( r*0.25, -r*0.05, r*0.10, 0, Math.PI*2);
      ctx.fill();

      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(-r*0.35, r*0.25);
      ctx.lineTo(-r*0.15, r*0.10);
      ctx.lineTo(0, r*0.25);
      ctx.lineTo(r*0.15, r*0.10);
      ctx.lineTo(r*0.35, r*0.25);
      ctx.stroke();
    }

    ctx.restore();
  }

  function draw(){
    drawMaze();
    drawPac();
    for (const g of ghosts) drawGhost(g);
  }

  // ======= Main loop (smooth) =======
  function frame(nowMs){
    if (!running) return;
    const now = nowMs/1000;
    let dt = now - lastT;
    if (dt > 0.05) dt = 0.05; // tab-switch safety
    lastT = now;

    if (!paused){
      accumulator += dt;
      while (accumulator >= FIXED_DT){
        step(FIXED_DT);
        accumulator -= FIXED_DT;
        if (!running) break;
      }
    }

    draw();
    updateHUD();
    requestAnimationFrame(frame);
  }

  // ======= init =======
  function init(){
    hardReset();
    updateHUD();
    draw();
  }

  init();
})();
</script>
</body>
</html>
