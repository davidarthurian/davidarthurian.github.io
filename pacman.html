<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pac-Man | David Arthurian</title>
  <style>
    :root{
      --bg:#0b1220;
      --text:#e6edf7;
      --muted:#9fb0c6;
      --border:rgba(255,255,255,0.10);
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      min-height:100vh;
      display:flex;
      flex-direction:column;
      align-items:center;
      padding:20px 14px;
      gap:12px;
    }
    .wrap{
      width:min(980px, 100%);
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .topRow{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
      padding:12px 14px;
      border:1px solid var(--border);
      border-radius:14px;
      background:rgba(255,255,255,0.03);
    }
    .stats{
      display:flex;
      gap:14px;
      flex-wrap:wrap;
      color:var(--muted);
      font-size:0.95rem;
    }
    .stats b{ color:var(--text); }
    button{
      border:1px solid var(--border);
      background:rgba(255,255,255,0.03);
      color:var(--text);
      padding:8px 12px;
      border-radius:12px;
      font-weight:700;
      cursor:pointer;
    }
    button:hover{ background:rgba(255,255,255,0.06); }
    canvas{
      width:100%;
      height:auto;
      border:1px solid var(--border);
      border-radius:16px;
      background:#050a12;
      display:block;
    }
    .hint{
      color:var(--muted);
      font-size:0.95rem;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="topRow">
      <div class="stats">
        <div>Score: <b id="score">0</b></div>
        <div>Lives: <b id="lives">3</b></div>
        <div>Status: <b id="status">Ready</b></div>
      </div>
      <div style="display:flex; gap:10px; flex-wrap:wrap;">
        <button id="startBtn">Start</button>
        <button id="resetBtn">Reset</button>
      </div>
    </div>

    <canvas id="c"></canvas>
    <div class="hint">Controls: Arrow keys / WASD. Tunnel wrap works on the open row (0 tiles).</div>
  </div>

<script>
(() => {
  // Tile legend:
  // 0 = empty corridor (used for tunnel row)
  // 1 = wall
  // 2 = pellet
  // 3 = power pellet
  // 4 = ghost house floor (walkable; pac can enter only if you allow — we allow for simplicity)

  const MAP = [
    "1111111111111111111111111111",
    "1222222222222112222222222221",
    "1211112111112112111112111121",
    "1311112111112112111112111131",
    "1211112111112112111112111121",
    "1222222222222222222222222221",
    "1211112112111111112112111121",
    "1211112112111111112112111121",
    "1222222112222112222112222221",
    "1111112111112112111112111111",
    "0000012111112112111112100000",
    "1111112112111111112112111111",
    "2222222222114444112222222222",
    "1111112112111111112112111111",
    "0000012111112112111112100000",
    "1111112112111111112112111111",
    "1222222222222112222222222221",
    "1211112111112112111112111121",
    "1311122222222222222222111131",
    "1111122112111111112112111111",
    "1222222112111111112112222221",
    "1211111112222112222111111121",
    "1211111111112112111111111121",
    "1222222222222222222222222221",
    "1111111111111111111111111111",
  ];

  const grid = MAP.map(row => row.split("").map(n => Number(n)));
  const ROWS = grid.length;
  const COLS = grid[0].length;

  // --- Canvas sizing ---
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  const TILE = 22; // tweak for size
  canvas.width = COLS * TILE;
  canvas.height = ROWS * TILE;

  // --- UI ---
  const scoreEl = document.getElementById("score");
  const livesEl = document.getElementById("lives");
  const statusEl = document.getElementById("status");
  const startBtn = document.getElementById("startBtn");
  const resetBtn = document.getElementById("resetBtn");

  // --- Helpers ---
  const isWall = (r, c) => {
    const t = tileAt(r, c);
    return t === 1; // IMPORTANT: only 1 is a wall. 4 is NOT a wall.
  };

  const tileAt = (r, c) => {
    if (r < 0 || r >= ROWS) return 1;
    // wrap columns for tunnel behavior, but only if that row has 0 corridor on edges
    if (c < 0) c = COLS - 1;
    if (c >= COLS) c = 0;
    return grid[r][c];
  };

  const setTile = (r, c, v) => {
    if (r < 0 || r >= ROWS) return;
    if (c < 0) c = COLS - 1;
    if (c >= COLS) c = 0;
    grid[r][c] = v;
  };

  const centerOf = (r, c) => ({ x: c * TILE + TILE/2, y: r * TILE + TILE/2 });

  // Find a safe spawn tile near the center/bottom (must be walkable: 0/2/3/4)
  // Your previous pac spawn was on (17,14) which is a WALL (1).
  const PAC_SPAWN = { r: 17, c: 12 }; // tile=2 here in your map
  const GHOST_SPAWNS = [
    { r: 12, c: 13 }, // all 4's in your map
    { r: 12, c: 14 },
    { r: 12, c: 15 },
    { r: 12, c: 14 }, // duplicate center but offset in pixel space
  ];

  // --- Game state ---
  let running = false;
  let gameOver = false;

  let score = 0;
  let lives = 3;

  // directions
  const DIRS = {
    LEFT:  { x:-1, y: 0 },
    RIGHT: { x: 1, y: 0 },
    UP:    { x: 0, y:-1 },
    DOWN:  { x: 0, y: 1 },
    NONE:  { x: 0, y: 0 },
  };

  const pac = {
    x: 0, y: 0,
    dir: DIRS.NONE,
    nextDir: DIRS.NONE,
    speed: 120, // px/sec
    radius: TILE * 0.42,
  };

  const ghosts = [
    { x:0,y:0, dir:DIRS.LEFT,  speed: 105, color:"#ff3b30" }, // red
    { x:0,y:0, dir:DIRS.RIGHT, speed: 100, color:"#34c759" }, // green
    { x:0,y:0, dir:DIRS.UP,    speed: 98,  color:"#0a84ff" }, // blue
    { x:0,y:0, dir:DIRS.DOWN,  speed: 102, color:"#ff9f0a" }, // orange
  ];

  function resetPositions() {
    const p = centerOf(PAC_SPAWN.r, PAC_SPAWN.c);
    pac.x = p.x; pac.y = p.y;
    pac.dir = DIRS.NONE;
    pac.nextDir = DIRS.NONE;

    ghosts.forEach((g, i) => {
      const s = GHOST_SPAWNS[i] || GHOST_SPAWNS[0];
      const c = centerOf(s.r, s.c);
      // tiny offsets so they don't overlap perfectly
      g.x = c.x + (i - 1.5) * 3;
      g.y = c.y + (i % 2 ? 3 : -3);
      g.dir = [DIRS.LEFT, DIRS.RIGHT, DIRS.UP, DIRS.DOWN][i % 4];
    });

    // Safety check: if spawn is accidentally in a wall, move it to nearest walkable
    if (isWall(tileRow(pac.y), tileCol(pac.x))) {
      const fix = findNearestWalkable(PAC_SPAWN.r, PAC_SPAWN.c);
      const cc = centerOf(fix.r, fix.c);
      pac.x = cc.x; pac.y = cc.y;
    }
    ghosts.forEach(g => {
      if (isWall(tileRow(g.y), tileCol(g.x))) {
        const fix = findNearestWalkable(12, 14);
        const cc = centerOf(fix.r, fix.c);
        g.x = cc.x; g.y = cc.y;
      }
    });
  }

  function resetGame(full = false) {
    if (full) {
      // restore pellets/power by reloading grid
      for (let r=0;r<ROWS;r++){
        for (let c=0;c<COLS;c++){
          grid[r][c] = Number(MAP[r][c]);
        }
      }
      score = 0;
      lives = 3;
    }
    gameOver = false;
    running = false;
    statusEl.textContent = "Ready";
    scoreEl.textContent = score;
    livesEl.textContent = lives;
    resetPositions();
    draw();
  }

  function tileRow(y){ return Math.floor(y / TILE); }
  function tileCol(x){ return Math.floor(x / TILE); }

  function isCenteredOnTile(entity) {
    const cx = entity.x % TILE;
    const cy = entity.y % TILE;
    const eps = 1.2; // tolerance
    return Math.abs(cx - TILE/2) < eps && Math.abs(cy - TILE/2) < eps;
  }

  function canMoveTo(x, y) {
    const r = tileRow(y);
    let c = tileCol(x);

    // Allow wrap through tunnel: when moving beyond canvas, wrap columns
    if (c < 0) c = COLS - 1;
    if (c >= COLS) c = 0;

    return !isWall(r, c);
  }

  function stepEntity(entity, dt) {
    const nx = entity.x + entity.dir.x * entity.speed * dt;
    const ny = entity.y + entity.dir.y * entity.speed * dt;

    // Wrap x through edges (OG style)
    let wrappedX = nx;
    if (wrappedX < 0) wrappedX += COLS * TILE;
    if (wrappedX >= COLS * TILE) wrappedX -= COLS * TILE;

    // Only accept move if target tile isn't a wall
    if (canMoveTo(wrappedX, ny)) {
      entity.x = wrappedX;
      entity.y = ny;
      return true;
    }

    // If blocked, snap to center of current tile for clean turns
    entity.x = Math.round(entity.x / 1) / 1;
    entity.y = Math.round(entity.y / 1) / 1;
    return false;
  }

  function tryTurnPac() {
    if (pac.nextDir === DIRS.NONE) return;

    // Only turn cleanly near the tile center
    if (!isCenteredOnTile(pac)) return;

    const testX = pac.x + pac.nextDir.x * TILE * 0.55;
    const testY = pac.y + pac.nextDir.y * TILE * 0.55;

    if (canMoveTo(testX, testY)) {
      pac.dir = pac.nextDir;
    }
  }

  function eat() {
    const r = tileRow(pac.y);
    const c = tileCol(pac.x);
    const t = tileAt(r, c);

    if (t === 2) { setTile(r, c, 0); score += 10; }
    if (t === 3) { setTile(r, c, 0); score += 50; }
    scoreEl.textContent = score;
  }

  function collide(a, b) {
    const dx = a.x - b.x;
    const dy = a.y - b.y;
    const dist = Math.hypot(dx, dy);
    return dist < TILE * 0.55;
  }

  function ghostAI(g) {
    // simple intersection turning:
    // when centered, choose a direction that isn't a wall, prefer heading toward pac
    if (!isCenteredOnTile(g)) return;

    const options = [DIRS.LEFT, DIRS.RIGHT, DIRS.UP, DIRS.DOWN].filter(d => {
      // don't reverse unless forced
      const reverse = (d.x === -g.dir.x && d.y === -g.dir.y);
      if (reverse) return false;
      const tx = g.x + d.x * TILE * 0.55;
      const ty = g.y + d.y * TILE * 0.55;
      return canMoveTo(tx, ty);
    });

    if (options.length === 0) {
      // allow reverse if stuck
      const rev = { x:-g.dir.x, y:-g.dir.y };
      g.dir = rev;
      return;
    }

    // choose option that reduces distance to pac most often (not perfect, but feels “chasey”)
    let best = options[0];
    let bestScore = Infinity;
    for (const d of options) {
      const tx = g.x + d.x * TILE;
      const ty = g.y + d.y * TILE;
      const s = Math.hypot(pac.x - tx, pac.y - ty);
      if (s < bestScore) { bestScore = s; best = d; }
    }

    // small randomness so they don't stack
    if (Math.random() < 0.18) {
      g.dir = options[Math.floor(Math.random() * options.length)];
    } else {
      g.dir = best;
    }
  }

  // Find nearest walkable tile if a spawn ever lands on a wall (safety net)
  function findNearestWalkable(sr, sc) {
    const q = [{r:sr, c:sc}];
    const seen = new Set([`${sr},${sc}`]);
    const ok = (r,c) => r>=0 && r<ROWS && c>=0 && c<COLS;
    const walk = (r,c) => grid[r][c] !== 1; // anything except wall

    while (q.length) {
      const cur = q.shift();
      if (walk(cur.r, cur.c)) return cur;
      for (const [dr,dc] of [[1,0],[-1,0],[0,1],[0,-1]]) {
        const nr = cur.r + dr, nc = cur.c + dc;
        const key = `${nr},${nc}`;
        if (!ok(nr,nc) || seen.has(key)) continue;
        seen.add(key);
        q.push({r:nr, c:nc});
      }
    }
    return {r:1,c:1};
  }

  // --- Rendering ---
  function draw() {
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // draw tiles
    for (let r=0;r<ROWS;r++){
      for (let c=0;c<COLS;c++){
        const t = grid[r][c];
        const x = c*TILE, y = r*TILE;

        if (t === 1) {
          ctx.fillStyle = "#0a2a8a";
          ctx.fillRect(x, y, TILE, TILE);
        } else {
          // background
          ctx.fillStyle = "#050a12";
          ctx.fillRect(x, y, TILE, TILE);

          // subtle grid lines
          ctx.strokeStyle = "rgba(255,255,255,0.035)";
          ctx.strokeRect(x, y, TILE, TILE);

          if (t === 2) {
            ctx.fillStyle = "#ffd60a";
            ctx.beginPath();
            ctx.arc(x+TILE/2, y+TILE/2, 2.2, 0, Math.PI*2);
            ctx.fill();
          }
          if (t === 3) {
            ctx.fillStyle = "#ffd60a";
            ctx.beginPath();
            ctx.arc(x+TILE/2, y+TILE/2, 5.0, 0, Math.PI*2);
            ctx.fill();
          }
          if (t === 4) {
            // ghost house floor tint
            ctx.fillStyle = "rgba(255,255,255,0.05)";
            ctx.fillRect(x, y, TILE, TILE);
          }
        }
      }
    }

    // Pac-Man (mouth animation)
    const mouth = running ? (0.25 + 0.15*Math.sin(perfNow/90)) : 0.25;
    ctx.fillStyle = "#ffd60a";
    ctx.beginPath();
    const angle = dirToAngle(pac.dir);
    ctx.moveTo(pac.x, pac.y);
    ctx.arc(pac.x, pac.y, pac.radius, angle + mouth, angle + Math.PI*2 - mouth);
    ctx.closePath();
    ctx.fill();

    // ghosts
    ghosts.forEach(g => drawGhost(g));

    // overlay
    if (!running && !gameOver) {
      overlayText("Press Start");
    }
    if (gameOver) {
      overlayText("Game Over");
    }
  }

  function overlayText(text){
    ctx.fillStyle = "rgba(0,0,0,0.55)";
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = "#e6edf7";
    ctx.font = "700 34px ui-sans-serif, system-ui";
    ctx.textAlign = "center";
    ctx.fillText(text, canvas.width/2, canvas.height/2);
    ctx.font = "500 16px ui-sans-serif, system-ui";
    ctx.fillStyle = "rgba(230,237,247,0.8)";
    ctx.fillText("Use arrow keys / WASD", canvas.width/2, canvas.height/2 + 28);
  }

  function dirToAngle(d){
    if (d === DIRS.RIGHT) return 0;
    if (d === DIRS.LEFT) return Math.PI;
    if (d === DIRS.UP) return -Math.PI/2;
    if (d === DIRS.DOWN) return Math.PI/2;
    return 0;
  }

  function drawGhost(g){
    const r = TILE * 0.42;
    const x = g.x, y = g.y;

    // body
    ctx.fillStyle = g.color;
    ctx.beginPath();
    ctx.arc(x, y, r, Math.PI, 0);
    ctx.lineTo(x + r, y + r);
    // wavy bottom
    for (let i=0;i<6;i++){
      const px = x + r - (i*(2*r/5));
      const py = y + r - (i%2 ? 4 : 0);
      ctx.lineTo(px, py);
    }
    ctx.closePath();
    ctx.fill();

    // eyes
    ctx.fillStyle = "#fff";
    ctx.beginPath();
    ctx.arc(x - r*0.35, y - r*0.15, r*0.22, 0, Math.PI*2);
    ctx.arc(x + r*0.35, y - r*0.15, r*0.22, 0, Math.PI*2);
    ctx.fill();

    // pupils
    const pdx = g.dir.x * 2.2;
    const pdy = g.dir.y * 2.2;
    ctx.fillStyle = "#111";
    ctx.beginPath();
    ctx.arc(x - r*0.35 + pdx, y - r*0.15 + pdy, r*0.10, 0, Math.PI*2);
    ctx.arc(x + r*0.35 + pdx, y - r*0.15 + pdy, r*0.10, 0, Math.PI*2);
    ctx.fill();
  }

  // --- Input ---
  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();
    if (k === "arrowleft" || k === "a") pac.nextDir = DIRS.LEFT;
    if (k === "arrowright" || k === "d") pac.nextDir = DIRS.RIGHT;
    if (k === "arrowup" || k === "w") pac.nextDir = DIRS.UP;
    if (k === "arrowdown" || k === "s") pac.nextDir = DIRS.DOWN;
  });

  startBtn.addEventListener("click", () => {
    if (gameOver) {
      resetGame(false);
    }
    running = true;
    statusEl.textContent = "Playing";
  });

  resetBtn.addEventListener("click", () => {
    resetGame(true);
  });

  // --- Loop (smooth) ---
  let last = performance.now();
  let perfNow = last;
  let accumulator = 0;
  const FIXED = 1/120; // 120 Hz sim for smoothness

  function tick(now){
    perfNow = now;
    const dt = Math.min(0.05, (now - last) / 1000);
    last = now;
    accumulator += dt;

    while (accumulator >= FIXED) {
      if (running && !gameOver) update(FIXED);
      accumulator -= FIXED;
    }

    draw();
    requestAnimationFrame(tick);
  }

  function update(dt){
    // turn if possible
    tryTurnPac();

    // move pac
    if (pac.dir !== DIRS.NONE) {
      const moved = stepEntity(pac, dt);
      if (!moved) pac.dir = DIRS.NONE;
    }

    // eat pellets
    eat();

    // ghosts
    ghosts.forEach(g => {
      ghostAI(g);
      stepEntity(g, dt);
      // collision check
      if (collide(pac, g)) {
        lives--;
        livesEl.textContent = lives;
        if (lives <= 0) {
          running = false;
          gameOver = true;
          statusEl.textContent = "Game Over";
        } else {
          running = false;
          statusEl.textContent = "Ready";
          resetPositions();
        }
      }
    });
  }

  // init
  resetGame(true);
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
