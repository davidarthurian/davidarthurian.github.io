<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Pac-Man | David Arthurian</title>
  <style>
    :root{
      --bg:#0b1220;
      --panel:#0f1a2e;
      --text:#e6edf7;
      --muted:#9fb0c6;
      --border:rgba(255,255,255,0.10);
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      background: radial-gradient(900px 600px at 80% 10%, rgba(125,211,252,0.12), transparent 60%),
                  radial-gradient(900px 600px at 20% 90%, rgba(167,139,250,0.10), transparent 60%),
                  var(--bg);
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      padding: 18px;
    }
    .wrap{
      width: min(980px, 100%);
      border:1px solid var(--border);
      background: rgba(15,26,46,0.55);
      border-radius: 18px;
      padding: 16px;
      box-shadow: 0 18px 60px rgba(0,0,0,0.35);
    }
    .top{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
      margin-bottom: 10px;
    }
    .title{
      font-weight: 800;
      letter-spacing:-0.2px;
    }
    .hud{
      display:flex;
      gap:12px;
      flex-wrap:wrap;
      color: var(--muted);
      font-size: 0.95rem;
    }
    canvas{
      width: 100%;
      height: auto;
      display:block;
      border-radius: 14px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.03);
    }
    .hint{
      margin-top: 10px;
      color: var(--muted);
      font-size: 0.95rem;
      line-height: 1.4;
    }
    .hint code{ color: var(--text); }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <div class="title">Pac-Man (Classic-ish)</div>
      <div class="hud">
        <div>Score: <span id="score">0</span></div>
        <div>Lives: <span id="lives">3</span></div>
        <div>Status: <span id="status">Ready</span></div>
      </div>
    </div>

    <canvas id="c"></canvas>

    <div class="hint">
      Controls: Arrow keys / WASD. <br/>
      To slow it down more, increase <code>TICK_MS</code>.
    </div>
  </div>

<script>
(() => {
  // ===== SPEED CONTROL =====
  // Bigger = slower. Try 160–220 if you want it calmer.
  const TICK_MS = 160;

  // ===== MAZE (must be a PERFECT rectangle: every row same length) =====
  // Legend:
  //  # wall
  //  . pellet
  //  o power pellet
  //  P pacman start
  //  G ghost start
  //  ' ' empty corridor (no pellet)
  const LEVEL = [
    "#####################",
    "#o........#........o#",
    "#.###.###.#.###.###.#",
    "#...................#",
    "#.###.#.#####.#.###.#",
    "#.....#...#...#.....#",
    "#####.### # ###.#####",
    "    #.#   G   #.#    ",
    "#####.# ##### #.#####",
    "P...... #   # ......#",
    "#####.# ##### #.#####",
    "    #.#   G   #.#    ",
    "#####.### # ###.#####",
    "#.....#...#...#.....#",
    "#.###.#.#####.#.###.#",
    "#...................#",
    "#.###.###.#.###.###.#",
    "#o........#........o#",
    "#####################"
  ];

  // Sanity check: keep the layout from getting “jumbled”
  const COLS = LEVEL[0].length;
  const ROWS = LEVEL.length;
  for (const row of LEVEL) {
    if (row.length !== COLS) {
      throw new Error("LEVEL rows are not the same length. Fix the maze strings.");
    }
  }

  const CELL = 26; // size of one tile in pixels
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  canvas.width = COLS * CELL;
  canvas.height = ROWS * CELL;

  const scoreEl = document.getElementById("score");
  const livesEl = document.getElementById("lives");
  const statusEl = document.getElementById("status");

  // Build grid + find spawns
  let grid = LEVEL.map(r => r.split(""));
  let pac = { r:0, c:0, dr:0, dc:0, nextDr:0, nextDc:0 };
  let ghosts = [];
  let pelletsLeft = 0;

  function resetWorld(keepScore=false) {
    grid = LEVEL.map(r => r.split(""));
    ghosts = [];
    pelletsLeft = 0;

    let pFound = false;
    for (let r=0; r<ROWS; r++){
      for (let c=0; c<COLS; c++){
        const ch = grid[r][c];
        if (ch === '.' || ch === 'o') pelletsLeft++;
        if (ch === 'P') {
          pac.r = r; pac.c = c;
          pac.dr = 0; pac.dc = 0;
          pac.nextDr = 0; pac.nextDc = 0;
          grid[r][c] = ' ';
          pFound = true;
        }
        if (ch === 'G') {
          ghosts.push({ r, c, dr:0, dc:0, scared:0 });
          grid[r][c] = ' ';
        }
      }
    }
    if (!pFound) { pac.r = ROWS-2; pac.c = 1; }

    if (!keepScore) score = 0;
    status = "Ready";
    gameOver = false;
    powerTimer = 0;

    scoreEl.textContent = String(score);
    statusEl.textContent = status;
  }

  // Game state
  let score = 0;
  let lives = 3;
  let status = "Ready";
  let gameOver = false;
  let powerTimer = 0;

  resetWorld(false);

  function isWall(r,c){
    if (r<0 || r>=ROWS || c<0 || c>=COLS) return true;
    return grid[r][c] === '#';
  }

  // Pac moves only when aligned to cell
  function canMove(r,c,dr,dc){
    const nr = r + dr;
    const nc = c + dc;
    return !isWall(nr,nc);
  }

  // Simple ghost AI: prefer continuing direction, otherwise random valid turn.
  function ghostStep(g){
    const dirs = [
      {dr:-1,dc:0}, {dr:1,dc:0}, {dr:0,dc:-1}, {dr:0,dc:1}
    ];

    // pick options (no walls)
    const options = dirs.filter(d => !isWall(g.r + d.dr, g.c + d.dc));

    // if current dir blocked or zero, choose a new one
    const curBlocked = isWall(g.r + g.dr, g.c + g.dc) || (g.dr===0 && g.dc===0);
    if (curBlocked) {
      const pick = options[Math.floor(Math.random()*options.length)];
      g.dr = pick.dr; g.dc = pick.dc;
    } else {
      // sometimes turn
      if (Math.random() < 0.18 && options.length > 1) {
        // avoid immediate reverse if possible
        const rev = {dr:-g.dr, dc:-g.dc};
        const nonReverse = options.filter(d => !(d.dr===rev.dr && d.dc===rev.dc));
        const pool = nonReverse.length ? nonReverse : options;
        const pick = pool[Math.floor(Math.random()*pool.length)];
        g.dr = pick.dr; g.dc = pick.dc;
      }
    }

    if (!isWall(g.r + g.dr, g.c + g.dc)) {
      g.r += g.dr;
      g.c += g.dc;
    }
  }

  function pacStep(){
    // try to apply buffered direction first
    if (canMove(pac.r, pac.c, pac.nextDr, pac.nextDc)) {
      pac.dr = pac.nextDr;
      pac.dc = pac.nextDc;
    }

    if (canMove(pac.r, pac.c, pac.dr, pac.dc)) {
      pac.r += pac.dr;
      pac.c += pac.dc;
    }

    // Eat pellet / power pellet
    const ch = grid[pac.r][pac.c];
    if (ch === '.') {
      grid[pac.r][pac.c] = ' ';
      score += 10;
      pelletsLeft--;
    } else if (ch === 'o') {
      grid[pac.r][pac.c] = ' ';
      score += 50;
      pelletsLeft--;
      powerTimer = 40; // ~40 ticks of power
      ghosts.forEach(g => g.scared = powerTimer);
    }
    scoreEl.textContent = String(score);
  }

  function checkCollisions(){
    for (const g of ghosts){
      if (g.r === pac.r && g.c === pac.c) {
        if (g.scared > 0) {
          // eat ghost
          score += 200;
          scoreEl.textContent = String(score);
          // send ghost back near center
          g.r = Math.floor(ROWS/2);
          g.c = Math.floor(COLS/2);
          g.dr = 0; g.dc = 0;
          g.scared = 0;
        } else {
          // lose life
          lives--;
          livesEl.textContent = String(lives);
          if (lives <= 0) {
            status = "Game Over";
            statusEl.textContent = status;
            gameOver = true;
          } else {
            status = "Ouch";
            statusEl.textContent = status;
            // reset positions only
            resetWorld(true);
            status = "Ready";
            statusEl.textContent = status;
          }
          return;
        }
      }
    }
  }

  function tick(){
    if (gameOver) return;

    status = "Playing";
    statusEl.textContent = status;

    if (powerTimer > 0) powerTimer--;
    ghosts.forEach(g => {
      if (g.scared > 0) g.scared--;
    });

    pacStep();
    ghosts.forEach(ghostStep);
    checkCollisions();

    if (pelletsLeft <= 0) {
      status = "You Win!";
      statusEl.textContent = status;
      gameOver = true;
    }

    draw();
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // background
    ctx.fillStyle = "rgba(255,255,255,0.02)";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // maze
    for (let r=0; r<ROWS; r++){
      for (let c=0; c<COLS; c++){
        const x = c*CELL, y = r*CELL;
        const ch = grid[r][c];

        if (ch === '#') {
          ctx.fillStyle = "rgba(125,211,252,0.22)";
          ctx.fillRect(x, y, CELL, CELL);
        } else if (ch === '.') {
          ctx.fillStyle = "rgba(230,237,247,0.9)";
          ctx.beginPath();
          ctx.arc(x + CELL/2, y + CELL/2, 2.5, 0, Math.PI*2);
          ctx.fill();
        } else if (ch === 'o') {
          ctx.fillStyle = "rgba(230,237,247,0.95)";
          ctx.beginPath();
          ctx.arc(x + CELL/2, y + CELL/2, 6, 0, Math.PI*2);
          ctx.fill();
        }
      }
    }

    // pacman
    ctx.fillStyle = "rgba(250, 204, 21, 0.95)";
    ctx.beginPath();
    ctx.arc(pac.c*CELL + CELL/2, pac.r*CELL + CELL/2, CELL*0.38, 0, Math.PI*2);
    ctx.fill();

    // ghosts
    for (const g of ghosts){
      ctx.fillStyle = g.scared > 0 ? "rgba(167,139,250,0.95)" : "rgba(248,113,113,0.95)";
      ctx.beginPath();
      ctx.arc(g.c*CELL + CELL/2, g.r*CELL + CELL/2, CELL*0.36, 0, Math.PI*2);
      ctx.fill();
    }
  }

  // Controls
  function setDir(dr,dc){
    pac.nextDr = dr; pac.nextDc = dc;
  }
  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();
    if (k === "arrowup" || k === "w") setDir(-1,0);
    if (k === "arrowdown" || k === "s") setDir(1,0);
    if (k === "arrowleft" || k === "a") setDir(0,-1);
    if (k === "arrowright" || k === "d") setDir(0,1);

    if (k === "enter" && gameOver) {
      lives = 3;
      livesEl.textContent = String(lives);
      resetWorld(false);
      draw();
      loop();
    }
  });

  let timer = null;
  function loop(){
    if (timer) clearInterval(timer);
    timer = setInterval(() => tick(), TICK_MS);
  }

  draw();
  loop();
})();
</script>
</body>
</html>
