<script>
(() => {
  // Tile legend:
  // 0 = empty corridor (used for tunnel row)
  // 1 = wall
  // 2 = pellet
  // 3 = power pellet
  // 4 = ghost house floor (walkable)

  const MAP = [
    "1111111111111111111111111111",
    "1222222222222112222222222221",
    "1211112111112112111112111121",
    "1311112111112112111112111131",
    "1211112111112112111112111121",
    "1222222222222222222222222221",
    "1211112112111111112112111121",
    "1211112112111111112112111121",
    "1222222112222112222112222221",
    "1111112111112112111112111111",
    "0000012111112112111112100000",
    "1111112112111111112112111111",
    "2222222222114444112222222222",
    "1111112112111111112112111111",
    "0000012111112112111112100000",
    "1111112112111111112112111111",
    "1222222222222112222222222221",
    "1211112111112112111112111121",
    "1311122222222222222222111131",
    "1111122112111111112112111111",
    "1222222112111111112112222221",
    "1211111112222112222111111121",
    "1211111111112112111111111121",
    "1222222222222222222222222221",
    "1111111111111111111111111111",
  ];

  let grid = MAP.map(row => row.split("").map(n => Number(n)));
  const ROWS = grid.length;
  const COLS = grid[0].length;

  // --- Canvas sizing ---
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  const TILE = 22;
  canvas.width = COLS * TILE;
  canvas.height = ROWS * TILE;

  // --- UI ---
  const scoreEl = document.getElementById("score");
  const livesEl = document.getElementById("lives");
  const statusEl = document.getElementById("status");
  const startBtn = document.getElementById("startBtn");
  const resetBtn = document.getElementById("resetBtn");

  // --- Helpers ---
  const tileRow = (y) => Math.floor(y / TILE);
  const tileCol = (x) => Math.floor(x / TILE);
  const centerOf = (r, c) => ({ x: c * TILE + TILE/2, y: r * TILE + TILE/2 });

  function isTunnelRow(r){
    if (r < 0 || r >= ROWS) return false;
    return grid[r][0] === 0 && grid[r][COLS-1] === 0;
  }

  // Wrap if entity is on a tunnel row (OG behavior)
  function wrapXIfTunnel(y, x){
    const r = tileRow(y);
    if (!isTunnelRow(r)) return x;
    const W = COLS * TILE;
    if (x < -TILE * 0.25) return x + W;
    if (x >= W + TILE * 0.25) return x - W;
    return x;
  }

  function tileAt(r, c){
    if (r < 0 || r >= ROWS) return 1;

    // Only allow column wrap on tunnel rows
    if (c < 0 || c >= COLS) {
      if (!isTunnelRow(r)) return 1;
      c = (c + COLS) % COLS;
    }
    return grid[r][c];
  }

  function setTile(r, c, v){
    if (r < 0 || r >= ROWS) return;

    if (c < 0 || c >= COLS) {
      if (!isTunnelRow(r)) return;
      c = (c + COLS) % COLS;
    }
    grid[r][c] = v;
  }

  function isWall(r, c){
    return tileAt(r, c) === 1;
  }

  function isCenteredOnTile(entity){
    const cx = entity.x % TILE;
    const cy = entity.y % TILE;
    const eps = 1.2;
    return Math.abs(cx - TILE/2) < eps && Math.abs(cy - TILE/2) < eps;
  }

  // --- Spawns ---
  const PAC_SPAWN = { r: 17, c: 12 };
  const GHOST_SPAWNS = [
    { r: 12, c: 13 },
    { r: 12, c: 14 },
    { r: 12, c: 15 },
    { r: 12, c: 14 },
  ];

  // Ghost exit corridor (door + tile above it) — we force these to be walkable
  const DOOR = { r: 11, c: 14 };
  const OUTSIDE = { r: 10, c: 14 }; // just above door (tunnel row)

  // --- Game state ---
  let running = false;
  let gameOver = false;
  let score = 0;
  let lives = 3;
  let gameTime = 0;

  // Frightened mode timer (power pellet)
  let frightenedUntil = 0;

  const DIRS = {
    LEFT:  { x:-1, y: 0 },
    RIGHT: { x: 1, y: 0 },
    UP:    { x: 0, y:-1 },
    DOWN:  { x: 0, y: 1 },
    NONE:  { x: 0, y: 0 },
  };

  const pac = {
    x: 0, y: 0,
    dir: DIRS.NONE,
    nextDir: DIRS.NONE,
    speed: 120,
    radius: TILE * 0.42,
  };

  const ghosts = [
    { x:0,y:0, dir:DIRS.LEFT,  speed:105, color:"#ff3b30", inHouse:true, releaseAt:0, dead:false },
    { x:0,y:0, dir:DIRS.RIGHT, speed:100, color:"#34c759", inHouse:true, releaseAt:0, dead:false },
    { x:0,y:0, dir:DIRS.UP,    speed: 98, color:"#0a84ff", inHouse:true, releaseAt:0, dead:false },
    { x:0,y:0, dir:DIRS.DOWN,  speed:102, color:"#ff9f0a", inHouse:true, releaseAt:0, dead:false },
  ];

  function findNearestWalkable(sr, sc){
    const q = [{r:sr, c:sc}];
    const seen = new Set([`${sr},${sc}`]);
    const ok = (r,c) => r>=0 && r<ROWS && c>=0 && c<COLS;
    const walk = (r,c) => grid[r][c] !== 1;

    while (q.length) {
      const cur = q.shift();
      if (walk(cur.r, cur.c)) return cur;
      for (const [dr,dc] of [[1,0],[-1,0],[0,1],[0,-1]]) {
        const nr = cur.r + dr, nc = cur.c + dc;
        const key = `${nr},${nc}`;
        if (!ok(nr,nc) || seen.has(key)) continue;
        seen.add(key);
        q.push({r:nr, c:nc});
      }
    }
    return {r:1,c:1};
  }

  function forceGhostDoorOpen(){
    // Make door and the outside tile walkable (so ghosts can actually leave)
    // Use 0 corridor (no pellet) so it feels like a clear doorway.
    setTile(DOOR.r, DOOR.c, 0);
    setTile(DOOR.r, DOOR.c - 1, 0);
    setTile(OUTSIDE.r, OUTSIDE.c, 0);
    setTile(OUTSIDE.r, OUTSIDE.c - 1, 0);
  }

  function resetPositions(){
    const p = centerOf(PAC_SPAWN.r, PAC_SPAWN.c);
    pac.x = p.x; pac.y = p.y;
    pac.dir = DIRS.NONE;
    pac.nextDir = DIRS.NONE;

    if (isWall(tileRow(pac.y), tileCol(pac.x))) {
      const fix = findNearestWalkable(PAC_SPAWN.r, PAC_SPAWN.c);
      const cc = centerOf(fix.r, fix.c);
      pac.x = cc.x; pac.y = cc.y;
    }

    ghosts.forEach((g, i) => {
      const s = GHOST_SPAWNS[i] || GHOST_SPAWNS[0];
      const c = centerOf(s.r, s.c);
      g.x = c.x + (i - 1.5) * 3;
      g.y = c.y + (i % 2 ? 3 : -3);
      g.dir = [DIRS.LEFT, DIRS.RIGHT, DIRS.UP, DIRS.DOWN][i % 4];
      g.inHouse = true;
      g.dead = false;
      g.releaseAt = gameTime + (i * 0.9); // staggered
    });
  }

  function resetGame(full=false){
    if (full) {
      grid = MAP.map(row => row.split("").map(n => Number(n)));
      score = 0;
      lives = 3;
      gameTime = 0;
      frightenedUntil = 0;
    }

    forceGhostDoorOpen();

    gameOver = false;
    running = false;
    statusEl.textContent = "Ready";
    scoreEl.textContent = score;
    livesEl.textContent = lives;
    resetPositions();
    draw();
  }

  // --- Robust collision: circle vs tile grid ---
  function hitsWallAt(x, y, radius){
    const r0 = tileRow(y - radius);
    const r1 = tileRow(y + radius);
    const c0 = tileCol(x - radius);
    const c1 = tileCol(x + radius);

    const pts = [
      {r:r0, c:c0}, {r:r0, c:c1},
      {r:r1, c:c0}, {r:r1, c:c1},
    ];

    for (const p of pts) {
      let rr = p.r;
      let cc = p.c;

      if (rr < 0 || rr >= ROWS) return true;

      if (cc < 0 || cc >= COLS) {
        if (!isTunnelRow(rr)) return true;
        cc = (cc + COLS) % COLS;
      }
      if (isWall(rr, cc)) return true;
    }
    return false;
  }

  // Axis-separated movement, with tunnel wrap
  function moveEntity(entity, dt){
    if (entity.dir === DIRS.NONE) return false;
    const r = entity.radius ?? (TILE * 0.40);

    // X
    let nx = entity.x + entity.dir.x * entity.speed * dt;
    let ny = entity.y;

    nx = wrapXIfTunnel(ny, nx);

    if (!hitsWallAt(nx, ny, r * 0.95)) {
      entity.x = nx;
    } else {
      const cr = tileRow(entity.y);
      const cc = tileCol(entity.x);
      const center = centerOf(cr, cc);
      entity.x = center.x;
      if (entity === pac) entity.dir = DIRS.NONE;
    }

    // Y
    nx = entity.x;
    ny = entity.y + entity.dir.y * entity.speed * dt;

    // Note: wrap uses current y; keep x wrap stable
    entity.x = wrapXIfTunnel(ny, entity.x);

    if (!hitsWallAt(entity.x, ny, r * 0.95)) {
      entity.y = ny;
    } else {
      const cr = tileRow(entity.y);
      const cc = tileCol(entity.x);
      const center = centerOf(cr, cc);
      entity.y = center.y;
      if (entity === pac) entity.dir = DIRS.NONE;
    }

    // final wrap
    entity.x = wrapXIfTunnel(entity.y, entity.x);
    return true;
  }

  function tryTurnPac(){
    if (pac.nextDir === DIRS.NONE) return;
    if (!isCenteredOnTile(pac)) return;

    const testX = wrapXIfTunnel(pac.y, pac.x + pac.nextDir.x * TILE * 0.55);
    const testY = pac.y + pac.nextDir.y * TILE * 0.55;

    if (!hitsWallAt(testX, testY, pac.radius * 0.95)) {
      pac.dir = pac.nextDir;
    }
  }

  function eat(){
    const r = tileRow(pac.y);
    const c = tileCol(pac.x);
    const t = tileAt(r, c);

    if (t === 2) {
      setTile(r, c, 0);
      score += 10;
    }
    if (t === 3) {
      setTile(r, c, 0);
      score += 50;

      // Frightened mode: 7 seconds
      frightenedUntil = Math.max(frightenedUntil, gameTime) + 7.0;
    }

    scoreEl.textContent = score;
  }

  function isFrightened(){
    return gameTime < frightenedUntil;
  }

  function collide(a, b){
    return Math.hypot(a.x - b.x, a.y - b.y) < TILE * 0.55;
  }

  function moveToward(g, target){
    const dx = target.x - g.x;
    const dy = target.y - g.y;

    // choose dominant axis
    if (Math.abs(dx) > Math.abs(dy)) {
      g.dir = dx > 0 ? DIRS.RIGHT : DIRS.LEFT;
    } else {
      g.dir = dy > 0 ? DIRS.DOWN : DIRS.UP;
    }
  }

  function ghostAI(g){
    // Dead ghosts go straight back into house (fast) then respawn
    if (g.dead) {
      g.speed = 150;
      const home = centerOf(GHOST_SPAWNS[1].r, GHOST_SPAWNS[1].c);
      moveToward(g, home);
      if (Math.hypot(g.x - home.x, g.y - home.y) < 3) {
        g.dead = false;
        g.inHouse = true;
        g.releaseAt = gameTime + 0.8; // re-release after a moment
        g.speed = g.baseSpeed ?? g.speed;
      }
      return;
    }

    // Release from house: go to door then to outside tile, then normal AI
    if (g.inHouse) {
      if (gameTime < g.releaseAt) {
        // idle wiggle
        if (isCenteredOnTile(g) && Math.random() < 0.25) {
          g.dir = [DIRS.LEFT, DIRS.RIGHT][Math.random() < 0.5 ? 0 : 1];
        }
        return;
      }

      const door = centerOf(DOOR.r, DOOR.c);
      const outside = centerOf(OUTSIDE.r, OUTSIDE.c);

      // step 1: reach door
      if (Math.hypot(g.x - door.x, g.y - door.y) > 2.5) {
        moveToward(g, door);
        return;
      }
      // step 2: go outside
      if (Math.hypot(g.x - outside.x, g.y - outside.y) > 2.5) {
        moveToward(g, outside);
        return;
      }

      g.inHouse = false;
      return;
    }

    // Normal AI at intersections
    if (!isCenteredOnTile(g)) return;

    const frightened = isFrightened();

    const options = [DIRS.LEFT, DIRS.RIGHT, DIRS.UP, DIRS.DOWN].filter(d => {
      const reverse = (d.x === -g.dir.x && d.y === -g.dir.y);
      if (reverse) return false;

      const tx = wrapXIfTunnel(g.y, g.x + d.x * TILE * 0.55);
      const ty = g.y + d.y * TILE * 0.55;
      return !hitsWallAt(tx, ty, TILE * 0.38);
    });

    if (options.length === 0) {
      g.dir = { x:-g.dir.x, y:-g.dir.y };
      return;
    }

    // chase when normal; flee when frightened
    let best = options[0];
    let bestScore = frightened ? -Infinity : Infinity;

    for (const d of options) {
      const tx = wrapXIfTunnel(g.y, g.x + d.x * TILE);
      const ty = g.y + d.y * TILE;
      const dist = Math.hypot(pac.x - tx, pac.y - ty);

      if (!frightened) {
        if (dist < bestScore) { bestScore = dist; best = d; }
      } else {
        if (dist > bestScore) { bestScore = dist; best = d; }
      }
    }

    g.dir = (Math.random() < 0.18)
      ? options[Math.floor(Math.random() * options.length)]
      : best;
  }

  // --- Rendering ---
  let last = performance.now();
  let perfNow = last;
  let accumulator = 0;
  const FIXED = 1/120;

  function dirToAngle(d){
    if (d === DIRS.RIGHT) return 0;
    if (d === DIRS.LEFT) return Math.PI;
    if (d === DIRS.UP) return -Math.PI/2;
    if (d === DIRS.DOWN) return Math.PI/2;
    return 0;
  }

  function overlayText(text){
    ctx.fillStyle = "rgba(0,0,0,0.55)";
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = "#e6edf7";
    ctx.font = "700 34px ui-sans-serif, system-ui";
    ctx.textAlign = "center";
    ctx.fillText(text, canvas.width/2, canvas.height/2);
    ctx.font = "500 16px ui-sans-serif, system-ui";
    ctx.fillStyle = "rgba(230,237,247,0.8)";
    ctx.fillText("Use arrow keys / WASD", canvas.width/2, canvas.height/2 + 28);
  }

  function drawGhost(g){
    const r = TILE * 0.42;
    const x = g.x, y = g.y;

    const frightened = isFrightened();
    const flashing = frightened && (frightenedUntil - gameTime) < 2.0 && (Math.floor(gameTime * 8) % 2 === 0);

    let bodyColor = g.color;
    if (g.dead) bodyColor = "rgba(255,255,255,0.0)";
    else if (frightened) bodyColor = flashing ? "#ffffff" : "#e9f3ff";

    // body
    ctx.fillStyle = bodyColor;
    ctx.beginPath();
    ctx.arc(x, y, r, Math.PI, 0);
    ctx.lineTo(x + r, y + r);
    for (let i=0;i<6;i++){
      const px = x + r - (i*(2*r/5));
      const py = y + r - (i%2 ? 4 : 0);
      ctx.lineTo(px, py);
    }
    ctx.closePath();
    ctx.fill();

    // eyes (keep readable)
    if (!g.dead) {
      ctx.fillStyle = "#fff";
      ctx.beginPath();
      ctx.arc(x - r*0.35, y - r*0.15, r*0.22, 0, Math.PI*2);
      ctx.arc(x + r*0.35, y - r*0.15, r*0.22, 0, Math.PI*2);
      ctx.fill();

      const pdx = g.dir.x * 2.2;
      const pdy = g.dir.y * 2.2;
      ctx.fillStyle = frightened ? "#0b1220" : "#111";
      ctx.beginPath();
      ctx.arc(x - r*0.35 + pdx, y - r*0.15 + pdy, r*0.10, 0, Math.PI*2);
      ctx.arc(x + r*0.35 + pdx, y - r*0.15 + pdy, r*0.10, 0, Math.PI*2);
      ctx.fill();
    }
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);

    for (let r=0;r<ROWS;r++){
      for (let c=0;c<COLS;c++){
        const t = grid[r][c];
        const x = c*TILE, y = r*TILE;

        if (t === 1) {
          ctx.fillStyle = "#0a2a8a";
          ctx.fillRect(x, y, TILE, TILE);
        } else {
          ctx.fillStyle = "#050a12";
          ctx.fillRect(x, y, TILE, TILE);

          ctx.strokeStyle = "rgba(255,255,255,0.035)";
          ctx.strokeRect(x, y, TILE, TILE);

          if (t === 2) {
            ctx.fillStyle = "#ffd60a";
            ctx.beginPath();
            ctx.arc(x+TILE/2, y+TILE/2, 2.2, 0, Math.PI*2);
            ctx.fill();
          }
          if (t === 3) {
            ctx.fillStyle = "#ffd60a";
            ctx.beginPath();
            ctx.arc(x+TILE/2, y+TILE/2, 5.0, 0, Math.PI*2);
            ctx.fill();
          }
          if (t === 4) {
            ctx.fillStyle = "rgba(255,255,255,0.05)";
            ctx.fillRect(x, y, TILE, TILE);
          }
        }
      }
    }

    // Pac-Man
    const mouth = running ? (0.25 + 0.15*Math.sin(perfNow/90)) : 0.25;
    ctx.fillStyle = "#ffd60a";
    ctx.beginPath();
    const angle = dirToAngle(pac.dir);
    ctx.moveTo(pac.x, pac.y);
    ctx.arc(pac.x, pac.y, pac.radius, angle + mouth, angle + Math.PI*2 - mouth);
    ctx.closePath();
    ctx.fill();

    ghosts.forEach(drawGhost);

    if (!running && !gameOver) overlayText("Press Start");
    if (gameOver) overlayText("Game Over");
  }

  // --- Input ---
  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();
    if (k === "arrowleft" || k === "a") pac.nextDir = DIRS.LEFT;
    if (k === "arrowright" || k === "d") pac.nextDir = DIRS.RIGHT;
    if (k === "arrowup" || k === "w") pac.nextDir = DIRS.UP;
    if (k === "arrowdown" || k === "s") pac.nextDir = DIRS.DOWN;
  });

  startBtn.addEventListener("click", () => {
    if (gameOver) resetGame(false);
    running = true;
    statusEl.textContent = "Playing";
  });

  resetBtn.addEventListener("click", () => resetGame(true));

  // --- Loop ---
  function tick(now){
    perfNow = now;
    const dt = Math.min(0.05, (now - last) / 1000);
    last = now;
    accumulator += dt;

    while (accumulator >= FIXED) {
      if (running && !gameOver) update(FIXED);
      accumulator -= FIXED;
    }

    draw();
    requestAnimationFrame(tick);
  }

  function update(dt){
    gameTime += dt;

    tryTurnPac();
    if (pac.dir !== DIRS.NONE) moveEntity(pac, dt);

    eat();

    for (const g of ghosts) {
      ghostAI(g);
      moveEntity(g, dt);

      if (collide(pac, g)) {
        if (isFrightened() && !g.dead && !g.inHouse) {
          // Eat ghost
          score += 200;
          scoreEl.textContent = score;
          g.dead = true;
          // send them back “home” (AI handles it)
        } else if (!isFrightened() && !g.dead) {
          // Pac dies
          lives--;
          livesEl.textContent = lives;

          if (lives <= 0) {
            running = false;
            gameOver = true;
            statusEl.textContent = "Game Over";
          } else {
            running = false;
            statusEl.textContent = "Ready";
            resetPositions();
          }
          break;
        }
      }
    }
  }

  // init
  resetGame(true);
  requestAnimationFrame(tick);
})();
</script>
