<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Fun | Gobblet Tic-Tac-Toe</title>
  <style>
    :root{
      --bg:#0b1220;
      --panel:#0f1a2e;
      --text:#e6edf7;
      --muted:#9fb0c6;
      --border:rgba(255,255,255,0.10);
      --blue:#60a5fa;   /* player */
      --red:#fb7185;    /* cpu */
      --chip: rgba(255,255,255,0.05);
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      min-height:100vh;
      display:flex;
      justify-content:center;
      align-items:center;
      padding: 18px;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color: var(--text);
      background:
        radial-gradient(900px 600px at 80% 10%, rgba(125,211,252,0.12), transparent 60%),
        radial-gradient(900px 600px at 20% 90%, rgba(167,139,250,0.10), transparent 60%),
        var(--bg);
    }

    .wrap{
      width:min(980px, 100%);
      border:1px solid var(--border);
      background: rgba(15,26,46,0.55);
      border-radius: 18px;
      padding: 16px;
      box-shadow: 0 18px 60px rgba(0,0,0,0.35);
    }

    .top{
      display:flex;
      justify-content:space-between;
      gap: 12px;
      flex-wrap:wrap;
      align-items:center;
      margin-bottom: 12px;
    }

    .title{
      font-weight: 900;
      letter-spacing: -0.2px;
    }

    .hud{
      display:flex;
      gap: 10px;
      flex-wrap:wrap;
      color: var(--muted);
      font-size: 0.95rem;
      align-items:center;
    }

    .pill{
      border:1px solid var(--border);
      background: rgba(255,255,255,0.03);
      border-radius: 999px;
      padding: 6px 10px;
      white-space:nowrap;
    }

    .btn{
      border:1px solid var(--border);
      background: rgba(255,255,255,0.04);
      color: var(--text);
      border-radius: 12px;
      padding: 10px 12px;
      font-weight: 700;
      cursor:pointer;
    }
    .btn:hover{ background: rgba(255,255,255,0.07); }

    .layout{
      display:grid;
      grid-template-columns: 1fr 340px;
      gap: 14px;
      align-items:start;
    }

    .board{
      border:1px solid var(--border);
      border-radius: 16px;
      overflow:hidden;
      background: rgba(255,255,255,0.03);
      display:grid;
      grid-template-columns: repeat(3, 1fr);
      aspect-ratio: 1 / 1;
    }

    .cell{
      position:relative;
      display:flex;
      align-items:center;
      justify-content:center;
      border-right:1px solid var(--border);
      border-bottom:1px solid var(--border);
      cursor:pointer;
      user-select:none;
      min-height: 120px;
    }
    .cell:nth-child(3n){ border-right:none; }
    .cell:nth-last-child(-n+3){ border-bottom:none; }
    .cell:hover{ background: rgba(255,255,255,0.03); }

    /* grid lines feel stronger */
    .board{ box-shadow: inset 0 0 0 1px rgba(255,255,255,0.02); }

    .piece{
      position:absolute;
      border-radius: 999px;
      opacity: 0.95;
      border: 2px solid rgba(255,255,255,0.25);
      box-shadow: 0 10px 26px rgba(0,0,0,0.35);
    }
    .blue{ background: rgba(96,165,250,0.95); }
    .red{ background: rgba(251,113,133,0.95); }

    /* sizes (relative to cell) */
    .s{ width: 32%; height: 32%; }
    .m{ width: 52%; height: 52%; }
    .l{ width: 74%; height: 74%; }

    .side{
      border:1px solid var(--border);
      border-radius: 16px;
      padding: 14px;
      background: rgba(255,255,255,0.03);
    }

    .sectionTitle{
      font-weight: 900;
      margin: 0 0 10px 0;
      letter-spacing:-0.2px;
    }

    .info{
      color: var(--muted);
      line-height: 1.4;
      font-size: 0.95rem;
      margin-bottom: 12px;
    }

    .piecePicker{
      display:flex;
      flex-direction:column;
      gap: 10px;
      margin-bottom: 12px;
    }

    .pickRow{
      display:flex;
      gap: 10px;
      flex-wrap:wrap;
      align-items:center;
    }

    .pickLabel{
      min-width: 70px;
      color: var(--muted);
      font-size: 0.95rem;
    }

    .chip{
      display:inline-flex;
      align-items:center;
      gap: 10px;
      padding: 8px 10px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: var(--chip);
      cursor:pointer;
      user-select:none;
    }
    .chip:hover{ background: rgba(255,255,255,0.08); }
    .chip[aria-disabled="true"]{
      opacity: 0.45;
      cursor:not-allowed;
    }
    .chip.active{
      outline: 2px solid rgba(125,211,252,0.45);
      background: rgba(125,211,252,0.10);
    }

    .dot{
      border-radius: 999px;
      border: 2px solid rgba(255,255,255,0.25);
      background: rgba(96,165,250,0.95);
      flex: 0 0 auto;
      box-shadow: 0 8px 22px rgba(0,0,0,0.25);
    }
    .dot.s{ width: 16px; height: 16px; }
    .dot.m{ width: 24px; height: 24px; }
    .dot.l{ width: 32px; height: 32px; }

    .counts{
      color: var(--muted);
      font-size: 0.95rem;
      margin-top: 6px;
    }

    .legend{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top: 10px;
    }

    .key{
      display:flex;
      align-items:center;
      gap:8px;
      border:1px solid var(--border);
      background: rgba(255,255,255,0.03);
      border-radius: 999px;
      padding: 6px 10px;
      color: var(--muted);
      font-size: 0.95rem;
    }
    .swatch{
      width: 12px;
      height: 12px;
      border-radius: 999px;
    }
    .swatch.blue{ background: var(--blue); }
    .swatch.red{ background: var(--red); }

    .toast{
      margin-top: 12px;
      border:1px solid var(--border);
      background: rgba(255,255,255,0.03);
      border-radius: 14px;
      padding: 10px 12px;
      color: var(--muted);
      line-height: 1.35;
      font-size: 0.95rem;
    }

    @media (max-width: 860px){
      .layout{ grid-template-columns: 1fr; }
      .cell{ min-height: 110px; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <div class="title">Gobblet Tic-Tac-Toe</div>
      <div class="hud">
        <span class="pill">Turn: <b id="turn">â€”</b></span>
        <span class="pill">Status: <b id="status">Ready</b></span>
        <button class="btn" id="startBtn">Start</button>
        <button class="btn" id="resetBtn">Reset</button>
      </div>
    </div>

    <div class="layout">
      <div class="board" id="board" aria-label="Game board"></div>

      <aside class="side">
        <div class="sectionTitle">Your pieces (Blue)</div>
        <div class="info">
          You have <b>2 small</b>, <b>2 medium</b>, <b>2 large</b>.
          You can place a piece on a cell if itâ€™s empty OR the top piece is smaller than your piece.
        </div>

        <div class="piecePicker" id="picker"></div>

        <div class="legend">
          <div class="key"><span class="swatch blue"></span> You</div>
          <div class="key"><span class="swatch red"></span> Computer</div>
        </div>

        <div class="toast" id="hint">
          Click <b>Start</b>, pick a size, then tap a cell.
        </div>
      </aside>
    </div>
  </div>

<script>
(() => {
  // Sizes: 1=small, 2=medium, 3=large
  const SIZE_INFO = {
    1: { key: "s", label: "Small", emoji: "â—" },
    2: { key: "m", label: "Medium", emoji: "â—" },
    3: { key: "l", label: "Large", emoji: "â—" },
  };

  // Each cell holds a stack of pieces: [{owner:'P'|'C', size:1|2|3}, ...]
  const stacks = Array.from({length:9}, () => []);

  // Inventory: 2 of each size
  const inv = {
    P: { 1:2, 2:2, 3:2 },
    C: { 1:2, 2:2, 3:2 },
  };

  // UI
  const boardEl = document.getElementById("board");
  const pickerEl = document.getElementById("picker");
  const statusEl = document.getElementById("status");
  const turnEl = document.getElementById("turn");
  const startBtn = document.getElementById("startBtn");
  const resetBtn = document.getElementById("resetBtn");
  const hintEl = document.getElementById("hint");

  // Game state
  let running = false;
  let turn = "P"; // P=player, C=computer
  let selectedSize = 2; // default
  let locked = false; // prevents double moves while CPU thinking

  // ===== Helpers =====
  function topPiece(i){
    const s = stacks[i];
    return s.length ? s[s.length - 1] : null;
  }

  function canPlace(owner, size, i){
    if (inv[owner][size] <= 0) return false;
    const top = topPiece(i);
    if (!top) return true;
    return size > top.size; // must be larger than top
  }

  function place(owner, size, i){
    stacks[i].push({ owner, size });
    inv[owner][size]--;
  }

  function visibleOwner(i){
    const top = topPiece(i);
    return top ? top.owner : null;
  }

  function visibleLineWinner(){
    const lines = [
      [0,1,2],[3,4,5],[6,7,8],
      [0,3,6],[1,4,7],[2,5,8],
      [0,4,8],[2,4,6]
    ];
    for (const [a,b,c] of lines){
      const A = visibleOwner(a), B = visibleOwner(b), C = visibleOwner(c);
      if (A && A === B && A === C) return A;
    }
    return null;
  }

  function anyMovesLeft(owner){
    for (let i=0;i<9;i++){
      for (const size of [1,2,3]){
        if (canPlace(owner,size,i)) return true;
      }
    }
    return false;
  }

  function updateHUD(){
    if (!running) {
      statusEl.textContent = "Ready";
      turnEl.textContent = "â€”";
    } else {
      statusEl.textContent = locked ? "Thinkingâ€¦" : "Playing";
      turnEl.textContent = (turn === "P") ? "You (Blue)" : "Computer (Red)";
    }
  }

  // ===== Rendering =====
  function renderBoard(){
    boardEl.innerHTML = "";
    for (let i=0;i<9;i++){
      const cell = document.createElement("div");
      cell.className = "cell";
      cell.dataset.i = String(i);

      // draw stack bottom-to-top (visually: only top matters, but weâ€™ll show depth by slight opacity)
      const stack = stacks[i];
      for (let k=0;k<stack.length;k++){
        const p = stack[k];
        const div = document.createElement("div");
        div.className = `piece ${p.owner === "P" ? "blue" : "red"} ${SIZE_INFO[p.size].key}`;
        // depth effect
        div.style.opacity = String(0.55 + 0.45*(k/(stack.length)));
        cell.appendChild(div);
      }

      cell.addEventListener("click", () => {
        if (!running || locked) return;
        if (turn !== "P") return;
        handlePlayerMove(i);
      });

      boardEl.appendChild(cell);
    }
  }

  function renderPicker(){
    pickerEl.innerHTML = "";

    const rows = [
      { size: 1, label: "Small" },
      { size: 2, label: "Medium" },
      { size: 3, label: "Large" },
    ];

    for (const row of rows){
      const wrap = document.createElement("div");
      wrap.className = "pickRow";

      const lab = document.createElement("div");
      lab.className = "pickLabel";
      lab.textContent = row.label;

      const chip = document.createElement("div");
      chip.className = "chip";
      chip.role = "button";

      const dot = document.createElement("span");
      dot.className = `dot ${SIZE_INFO[row.size].key}`;

      const text = document.createElement("div");
      text.innerHTML = `<b>${inv.P[row.size]}</b> left`;

      chip.appendChild(dot);
      chip.appendChild(text);

      const disabled = inv.P[row.size] <= 0;
      chip.setAttribute("aria-disabled", disabled ? "true" : "false");
      if (!disabled && selectedSize === row.size) chip.classList.add("active");
      if (disabled) chip.style.pointerEvents = "none";

      chip.addEventListener("click", () => {
        if (!running || locked) return;
        selectedSize = row.size;
        renderPicker();
        hintEl.textContent = `Selected: ${row.label}. Tap a board cell to place it.`;
      });

      wrap.appendChild(lab);
      wrap.appendChild(chip);
      pickerEl.appendChild(wrap);
    }
  }

  function setHint(msg){ hintEl.textContent = msg; }

  function resetAll(){
    for (let i=0;i<9;i++) stacks[i] = [];
    inv.P[1]=2; inv.P[2]=2; inv.P[3]=2;
    inv.C[1]=2; inv.C[2]=2; inv.C[3]=2;
    selectedSize = 2;
    turn = "P";
    running = false;
    locked = false;
    setHint("Click Start, pick a size, then tap a cell.");
    updateHUD();
    renderBoard();
    renderPicker();
  }

  // ===== Gameplay =====
  function endGame(message){
    running = false;
    locked = false;
    updateHUD();
    setHint(message + " Press Start to play again.");
  }

  function afterMove(){
    renderBoard();
    renderPicker();

    const winner = visibleLineWinner();
    if (winner){
      if (winner === "P") endGame("âœ… You win!");
      else endGame("ðŸ’€ Computer wins!");
      return;
    }

    // If neither side can move, it's a draw
    if (!anyMovesLeft("P") && !anyMovesLeft("C")){
      endGame("ðŸ¤ Draw â€” no moves left.");
      return;
    }

    // Next turn
    turn = (turn === "P") ? "C" : "P";
    locked = (turn === "C");
    updateHUD();

    if (turn === "C"){
      setHint("Computer thinkingâ€¦");
      // slight delay feels nicer
      setTimeout(cpuMove, 380);
    } else {
      setHint("Your turn â€” pick a size and place it.");
    }
  }

  function handlePlayerMove(i){
    const size = selectedSize;
    if (!canPlace("P", size, i)){
      const top = topPiece(i);
      if (!top) setHint("You canâ€™t place that size (no pieces left).");
      else setHint(`Needs to be larger than the top piece (${sizeName(top.size)}).`);
      return;
    }
    place("P", size, i);
    afterMove();
  }

  function sizeName(s){
    return s===1?"Small":s===2?"Medium":"Large";
  }

  // ===== Basic AI =====
  // Strategy:
  // 1) Win now (any size, any cell)
  // 2) Block player's win
  // 3) Prefer center if possible
  // 4) Otherwise choose a move that increases chance (corners, edges)
  function cpuMove(){
    if (!running) return;

    const move =
      findWinningMove("C") ||
      findWinningMove("P", /*block*/true) ||
      findPreferredMove();

    if (!move){
      // no move possible
      endGame("ðŸ¤ Draw â€” computer has no moves.");
      return;
    }

    place("C", move.size, move.i);
    afterMove();
  }

  function simulatePlace(owner, size, i){
    stacks[i].push({ owner, size });
    const w = visibleLineWinner();
    stacks[i].pop();
    return w;
  }

  function findWinningMove(targetOwner, block=false){
    // If block=true, we simulate targetOwner winning, then CPU places a move that prevents it by making itself win? â€”
    // easier: just find player-winning moves and place something bigger on those cells if possible.
    if (!block){
      // CPU tries to win: simulate CPU move
      for (let i=0;i<9;i++){
        for (const size of [1,2,3]){
          if (!canPlace("C", size, i)) continue;
          const w = simulatePlace("C", size, i);
          if (w === "C") return { i, size };
        }
      }
      return null;
    } else {
      // Block player: find any player move that would win, then cover that cell with a legal CPU piece
      for (let i=0;i<9;i++){
        for (const pSize of [1,2,3]){
          // simulate player making a winning move
          if (inv.P[pSize] <= 0) continue;
          const top = topPiece(i);
          const playerCan = (!top) ? true : (pSize > top.size);
          if (!playerCan) continue;

          const w = simulatePlace("P", pSize, i);
          if (w === "P") {
            // can CPU place something on i to prevent? It must be > current top (which is whatever is there now, not the simulated move).
            // Realistically, the block needs to occupy that cell now with any legal move.
            for (const cSize of [1,2,3]){
              if (canPlace("C", cSize, i)) return { i, size: cSize };
            }
          }
        }
      }
      return null;
    }
  }

  function findPreferredMove(){
    // Prefer center, then corners, then edges. Also prefer using smallest size that is legal (save big pieces).
    const order = [4,0,2,6,8,1,3,5,7];
    for (const i of order){
      for (const size of [1,2,3]){
        if (canPlace("C", size, i)) return { i, size };
      }
    }
    return null;
  }

  // ===== Buttons =====
  startBtn.addEventListener("click", () => {
    // Start also acts like "play again"
    if (!running){
      resetAll();
      running = true;
      turn = "P";
      locked = false;
      updateHUD();
      setHint("Your turn â€” pick a size and place it.");
    } else {
      // if already running, do nothing
      setHint("Game is already running.");
    }
  });

  resetBtn.addEventListener("click", () => {
    resetAll();
  });

  // Initial render
  resetAll();
})();
</script>
</body>
</html>
